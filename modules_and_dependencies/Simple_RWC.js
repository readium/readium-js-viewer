var SimpleRWC = function (elementToBindReaderTo, viewerPreferences, packageDocumentURL, packageDocumentXML) {
    
    // Epub modules
    var EpubCFI = {};
    var EpubReflowable = {};
    var EpubFixed = {};
    var EpubParser = {};
    var Epub = {};
    var EpubReader = {};
    var EpubAnnotations = {};

    // Rationale: The order of these matters
    var EpubCFIModule = function () {
    
    var EPUBcfi = {};

    EPUBcfi.Parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "fragment": parse_fragment,
        "range": parse_range,
        "path": parse_path,
        "local_path": parse_local_path,
        "indexStep": parse_indexStep,
        "indirectionStep": parse_indirectionStep,
        "terminus": parse_terminus,
        "idAssertion": parse_idAssertion,
        "textLocationAssertion": parse_textLocationAssertion,
        "parameter": parse_parameter,
        "csv": parse_csv,
        "valueNoSpace": parse_valueNoSpace,
        "value": parse_value,
        "escapedSpecialChars": parse_escapedSpecialChars,
        "number": parse_number,
        "integer": parse_integer,
        "space": parse_space,
        "circumflex": parse_circumflex,
        "doubleQuote": parse_doubleQuote,
        "squareBracket": parse_squareBracket,
        "parentheses": parse_parentheses,
        "comma": parse_comma,
        "semicolon": parse_semicolon,
        "equal": parse_equal,
        "character": parse_character
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "fragment";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_fragment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "epubcfi(") {
          result0 = "epubcfi(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"epubcfi(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_range();
          if (result1 === null) {
            result1 = parse_path();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, fragmentVal) { 
                
                return { type:"CFIAST", cfiString:fragmentVal };
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_range() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result2 = ",";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_local_path();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  result4 = ",";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_local_path();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {
        
                return { type:"range", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };
          })(pos0, result0[0], result0[1], result0[3], result0[5]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal) { 
        
                return { type:"path", path:stepVal, localPath:localPathVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_indexStep();
        if (result1 === null) {
          result1 = parse_indirectionStep();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_indexStep();
            if (result1 === null) {
              result1 = parse_indirectionStep();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_terminus();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, localPathStepVal, termStepVal) { 
        
                return { steps:localPathStepVal, termStep:termStepVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indexStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indirectionStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!/") {
          result0 = "!/";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_terminus() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_textLocationAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, textOffsetValue, textLocAssertVal) { 
        
                return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_idAssertion() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_value();
        if (result0 !== null) {
          result0 = (function(offset, idVal) { 
        
                return idVal; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_textLocationAssertion() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_csv();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_parameter();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, csvVal, paramVal) { 
        
                return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parameter() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_valueNoSpace();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 61) {
              result2 = "=";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_valueNoSpace();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, paramLHSVal, paramRHSVal) { 
        
                return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal }; 
            })(pos0, result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_csv() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_value();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_value();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preAssertionVal, postAssertionVal) { 
        
                return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal }; 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_valueNoSpace() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
          if (result1 === null) {
            result1 = parse_space();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
              if (result1 === null) {
                result1 = parse_space();
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_escapedSpecialChars() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_circumflex();
        if (result0 !== null) {
          result1 = parse_circumflex();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_circumflex();
          if (result0 !== null) {
            result1 = parse_squareBracket();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            result0 = parse_circumflex();
            if (result0 !== null) {
              result1 = parse_parentheses();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              result0 = parse_circumflex();
              if (result0 !== null) {
                result1 = parse_comma();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                result0 = parse_circumflex();
                if (result0 !== null) {
                  result1 = parse_semicolon();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_circumflex();
                  if (result0 !== null) {
                    result1 = parse_equal();
                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, escSpecCharVal) { 
                
                return escSpecCharVal[1]; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        if (/^[1-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            pos2 = pos;
            result2 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result2 !== null) {
              if (/^[1-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, intPartVal, fracPartVal) { 
        
                return intPartVal.join('') + "." + fracPartVal.join(''); 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 === null) {
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, integerVal) { 
        
                if (integerVal === "0") { 
                  return "0";
                } 
                else { 
                  return integerVal[0].concat(integerVal[1].join(''));
                }
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_circumflex() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 94) {
          result0 = "^";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"^\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "^"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuote() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return '"'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_squareBracket() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parentheses() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_equal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_character() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 === null) {
          if (/^[A-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Z]");
            }
          }
          if (result0 === null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
 
    // Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL). 
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

EPUBcfi.CFIInstructions = {

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	// Description: Follows a step
	// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
	//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been 
	//   excluded.
	// REFACTORING CANDIDATE: This should be called "followIndexStep"
	getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		// Find the jquery index for the current node
		var $targetNode;
		if (CFIStepValue % 2 == 0) {

			$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}
		else {

			$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}

		return $targetNode;
	},

	// Description: This instruction executes an indirection step, where a resource is retrieved using a 
	//   link contained on a attribute of the target element. The attribute that contains the link differs
	//   depending on the target. 
	// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to 
	//   the cross origin security policy
	followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var that = this;
		var $contentDocument; 
		var $blacklistExcluded;
		var $startElement;
		var $targetNode;

		// TODO: This check must be expanded to all the different types of indirection step
		// Only expects iframes, at the moment
		if ($currNode === undefined || !$currNode.is("iframe")) {

			throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
		}

		// Check node type; only iframe indirection is handled, at the moment
		if ($currNode.is("iframe")) {

			// Get content
			$contentDocument = $currNode.contents();

			// Go to the first XHTML element, which will be the first child of the top-level document object
			$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
			$startElement = $($blacklistExcluded[0]);

			// Follow an index step
			$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return that shit!
			return $targetNode; 
		}

		// TODO: Other types of indirection
		// TODO: $targetNode.is("embed")) : src
		// TODO: ($targetNode.is("object")) : data
		// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
	},

	// Description: Injects an element at the specified text node
	// Arguments: a cfi text termination string, a jquery object to the current node
	// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus
	textTermination : function ($currNode, textOffset, elementToInject) {

		var $injectedElement;
		// Get the first node, this should be a text node
		if ($currNode === undefined) {

			throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
		} 
		else if ($currNode.length === 0) {

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
		}

		$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
		return $injectedElement;
	},

	// Description: Checks that the id assertion for the node target matches that on 
	//   the found node. 
	targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

		if ($foundNode.attr("id") === idAssertion) {

			return true;
		}
		else {

			return false;
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
	elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var $targetNode;
		var $blacklistExcluded;
		var numElements;
		var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

		$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
		numElements = $blacklistExcluded.length;

		if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

			throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
		}

	    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
		return $targetNode;
	},

	retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

		return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
	},

	indexOutOfRange : function (targetIndex, numChildElements) {

		return (targetIndex > numChildElements - 1) ? true : false;
	},

	// Rationale: In order to inject an element into a specific position, access to the parent object 
	//   is required. This is obtained with the jquery parent() method. An alternative would be to 
	//   pass in the parent with a filtered list containing only children that are part of the target text node.
	injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

		var nodeNum;
		var currNodeLength;
		var currTextPosition = 0;
		var nodeOffset;
		var originalText;
		var $injectedNode;
		var $newTextNode;
		// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
		for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {

			if ($textNodeList[nodeNum].nodeType === 3) {

				currNodeMaxIndex = ($textNodeList[nodeNum].nodeValue.length - 1) + currTextPosition;
				nodeOffset = textOffset - currTextPosition;

				if (currNodeMaxIndex >= textOffset) {

					// This node is going to be split and the components re-inserted
					originalText = $textNodeList[nodeNum].nodeValue;	

					// Before part
				 	$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

					// Injected element
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

					// After part
					$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
					$($newTextNode).insertAfter($injectedNode);

					return $injectedNode;
				}
				else {

					currTextPosition = currTextPosition + currNodeMaxIndex;
				}
			}
		}

		throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
	},

	// Description: This method finds a target text node and then injects an element into the appropriate node
	// Arguments: A step value that is an odd integer. A current node with a set of child elements.
	// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to 
	//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
	//   the set of nodes that compromised the original target text node are inferred and returned.
	// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, 
	//   element nodes (maybe), or possibly a mix. 
	// REFACTORING CANDIDATE: This method is pretty long. Worth investigating to see if it can be refactored into something clearer.
	inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {
		
		var $elementsWithoutMarkers;
		var currTextNodePosition;
		var logicalTargetPosition;
		var nodeNum;
		var $targetTextNodeList;

		// Remove any cfi marker elements from the set of elements. 
		// Rationale: A filtering function is used, as simply using a class selector with jquery appears to 
		//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
		$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

		// Convert CFIStepValue to logical index; assumes odd integer for the step value
		logicalTargetPosition = (parseInt(CFIStepValue) + 1) / 2;

		// Set text node position counter
		currTextNodePosition = 1;
		$targetTextNodeList = $elementsWithoutMarkers.filter(
			function () {

				if (currTextNodePosition === logicalTargetPosition) {

					// If it's a text node
					if (this.nodeType === 3) {
						return true; 
					}
					// Any other type of node, move onto the next text node
					else {
						currTextNodePosition++; 
						return false;
					}
				}
				// In this case, don't return any elements
				else {

					// If its the last child and it's not a text node, there are no text nodes after it
					// and the currTextNodePosition shouldn't be incremented
					if (this.nodeType !== 3 && this !== $elementsWithoutMarkers.lastChild) {
						currTextNodePosition++;
					}

					return false;
				}
			}
		);

		// The filtering above should have counted the number of "logical" text nodes; this can be used to 
		// detect out of range errors
		if ($targetTextNodeList.length === 0) {

			throw EPUBcfi.OutOfRangeError(logicalTargetPosition, currTextNodePosition - 1, "Index out of range");
		}

		// return the text node list
		return $targetTextNodeList;
	},

	applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

        var $filteredElements;

        $filteredElements = $elements.filter(
            function () {

                var $currElement = $(this);
                var includeInList = true;

                if (classBlacklist) {

                	// Filter each element with the class type
                	$.each(classBlacklist, function (index, value) {

	                    if ($currElement.hasClass(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
                	});
                }

                if (elementBlacklist) {
                	
	                // For each type of element
	                $.each(elementBlacklist, function (index, value) {

	                    if ($currElement.is(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

				if (idBlacklist) {
                	
	                // For each type of element
	                $.each(idBlacklist, function (index, value) {

	                    if ($currElement.attr("id") === value) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

                return includeInList;
            }
        );

        return $filteredElements;
    }
};



    // Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

EPUBcfi.Interpreter = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Find the content document referenced by the spine item. This should be the spine item 
    //   referenced by the first indirection step in the CFI.
    // Rationale: This method is a part of the API so that the reading system can "interact" the content document 
    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with 
    //   the reading system, as it stands now. 
    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var $packageDocument = $(packageDocument);
        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        if (!CFIAST || CFIAST.type !== "CFIAST") { 
            throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
        }

        // Interpet the path node (the package document step)
        var $packageElement = $($("package", $packageDocument)[0]);
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);
        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);

        if (foundHref) {
            return foundHref;
        }
        else {
            return undefined;
        }
    },

    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

        // Return the element that was injected into
        return $currElement;
    },

    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI
    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(rangeCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        var $range1TargetElement;
        var $range2TargetElement;

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps in the first local path
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the first range local_path
        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);

        // Interpret the second range local_path
        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);
        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);

        // Return the element that was injected into
        return {
            startElement : $range1TargetElement[0],
            endElement : $range2TargetElement[0]
        };
    },

    // Description: This method will return the element or node (say, a text node) that is the final target of the 
    //   the CFI.
    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;
    },

    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(rangeCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var $currElement;
        var $range1TargetElement;
        var $range2TargetElement;
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret first range local_path
        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Interpret second range local_path
        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return {
            startElement : $range1TargetElement[0],
            endElement : $range2TargetElement[0]
        };
    },

    // Description: This method allows a "partial" CFI to be used to reference a target in a content document, without a 
    //   package document CFI component. 
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;        
    },

    // Description: This method allows a "partial" CFI to be used, with a content document, to return the text node and offset 
    //    referenced by the partial CFI.
    // Arguments: {
    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be 
    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that
    //        that has no defined meaning in the spec.)
    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. 
    // }
    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care
    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(contentDocumentCFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var textOffset;
        
        // Interpret the path node 
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);
        return { textNode : $currElement,
                 textOffset : textOffset
            };
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    getFirstIndirectionStepNum : function (CFIAST) {

        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it 
        //   references is already loaded and has been passed to this method
        var stepNum = 0;
        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indirectionStep") {
                return stepNum;
            }
        }
    },

    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the 
    //   starting step... probably a good idea, this would make the meaning of this method clearer.
    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        var stepNum = startStepNum;
        var nextStepNode;
        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {
        
            nextStepNode = localPathNode.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
        }

        return $currElement;
    },

    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

            throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
        }

        // Index step
        var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Check the id assertion, if it exists
        if (indexStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

            throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
        }

        // Indirection step
        var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
            indirectionStepNode.stepLength, 
            $currElement, 
            classBlacklist, 
            elementBlacklist);

        // Check the id assertion, if it exists
        if (indirectionStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus
    //   to inject content into the found node. This will not always be the case, and different types of interpretation
    //   are probably desired. 
    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

        if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

            throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
        }

        var $injectedElement = EPUBcfi.CFIInstructions.textTermination(
            $currElement, 
            terminusNode.offsetValue, 
            elementToInject
            );

        return $injectedElement;
    },

    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {

        // Interpret the first local_path node, which is a set of steps and and a terminus condition
        var stepNum = 0;
        var nextStepNode;
        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {
        
            nextStepNode = localPathNode.steps[stepNum];
            if (nextStepNode.type === "indexStep") {
                
                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }

            // Found the content document href referenced by the spine item 
            if ($currElement.is("itemref")) {

                return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
            }
        }

        return undefined;
    }
};
    // Description: This is a set of runtime errors that the CFI interpreter can throw. 
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
EPUBcfi.NodeTypeError = function (node, message) {

    function NodeTypeError () {

        this.node = node;
    }

    NodeTypeError.prototype = new Error(message);
    NodeTypeError.constructor = NodeTypeError;

    return new NodeTypeError();
};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

    function OutOfRangeError () {

        this.targetIndex = targetIndex;
        this.maxIndex = maxIndex;
    }

    OutOfRangeError.prototype = new Error(message);
    OutOfRangeError.constructor = OutOfRangeError()

    return new OutOfRangeError();
};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

    function TerminusError () {

        this.terminusType = terminusType;
        this.terminusCondition = terminusCondition;
    }

    TerminusError.prototype = new Error(message);
    TerminusError.constructor = TerminusError();

    return new TerminusError();
};

EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

    function CFIAssertionError () {

        this.expectedAssertion = expectedAssertion;
        this.targetElementAssertion = targetElementAssertion;
    }

    CFIAssertionError.prototype = new Error(message);
    CFIAssertionError.constructor = CFIAssertionError();

    return new CFIAssertionError();
};

    EPUBcfi.Generator = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var docRange;
        var commonAncestor;
        var range1OffsetStep;
        var range1CFI;
        var range2OffsetStep;
        var range2CFI;
        var commonCFIComponent;

        this.validateStartTextNode(rangeStartElement);
        this.validateStartTextNode(rangeEndElement);

        if (rangeStartElement === rangeEndElement) {
            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          
            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), "html", classBlacklist, elementBlacklist, idBlacklist);
            return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1OffsetStep + "," + range2OffsetStep;
        }
        else {

            // Create a document range to find the common ancestor
            docRange = document.createRange();
            docRange.setStart(rangeStartElement, startOffset);
            docRange.setEnd(rangeEndElement, endOffset);
            commonAncestor = docRange.commonAncestorContainer;

            // Generate terminating offset and range 1
            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);
            range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;

            // Generate terminating offset and range 2
            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);
            range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;

            // Generate shared component
            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

            // Return the result
            return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
        }
    },

    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {

        var docRange;
        var commonAncestor;
        var range1CFI;
        var range2CFI;
        var commonCFIComponent;

        this.validateStartElement(rangeStartElement);
        this.validateStartElement(rangeEndElement);

        if (rangeStartElement === rangeEndElement) {
            throw new Error("Start and end element cannot be the same for a CFI range");
        }

        // Create a document range to find the common ancestor
        docRange = document.createRange();
        docRange.setStart(rangeStartElement);
        docRange.setEnd(rangeEndElement);
        commonAncestor = docRange.commonAncestorContainer;

        // Generate range 1
        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

        // Generate range 2
        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);

        // Generate shared component
        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Return the result
        return commonCFIComponent.substring(1, commonCFIComponent.length) + "," + range1CFI + "," + range2CFI;
    },

    // Description: Generates a character offset CFI 
    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the 
    //   content document that contains the text node, the package document for this EPUB.
    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var textNodeStep;
        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartTextNode(startTextNode, characterOffset);

        // Create the text node step
        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), "html", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {

        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateStartElement(startElement);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startElement), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Remove the ! 
        return contentDocCFI.substring(1, contentDocCFI.length);
    },

    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        this.validateContentDocumentName(contentDocumentName);
        this.validatePackageDocument(packageDocument, contentDocumentName);

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Append an !; this assumes that a CFI content document CFI component will be appended at some point
        return packageDocCFIComponent + "!";
    },

    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $($("spine", packageDocument).children()[spineIndex]);

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Append an !; this assumes that a CFI content document CFI component will be appended at some point
        return packageDocCFIComponent + "!";
    },

    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {

        return "epubcfi(" + packageDocumentCFIComponent + contentDocumentCFIComponent + ")";  
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    validateStartTextNode : function (startTextNode, characterOffset) {
        
        // Check that the text node to start from IS a text node
        if (!startTextNode) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        } else if (startTextNode.nodeType != 3) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        }

        // Check that the character offset is within a valid range for the text node supplied
        if (characterOffset < 0) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
        }
        else if (characterOffset > startTextNode.nodeValue.length) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
        }
    },

    validateStartElement : function (startElement) {

        if (!startElement) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is undefined");
        }

        if (!(startElement.nodeType && startElement.nodeType === 1)) {
            throw new EPUBcfi.NodeTypeError(startElement, "CFI target element is not an HTML element");
        }
    },

    validateContentDocumentName : function (contentDocumentName) {

        // Check that the idref for the content document has been provided
        if (!contentDocumentName) {
            throw new Error("The idref for the content document, as found in the spine, must be supplied");
        }
    },

    validatePackageDocument : function (packageDocument, contentDocumentName) {
        
        // Check that the package document is non-empty and contains an itemref element for the supplied idref
        if (!packageDocument) {
            throw new Error("A package document must be supplied to generate a CFI");
        }
        else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
            throw new Error("The idref of the content document could not be found in the spine");
        }
    },

    // Description: Creates a CFI terminating step, to a text node, with a character offset
    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var CFIIndex;
        var indexOfTextNode;
        var preAssertion;
        var preAssertionStartIndex;
        var textLength;
        var postAssertion;
        var postAssertionEndIndex;

        // Find text node position in the set of child elements, ignoring any blacklisted elements 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node index in the parent list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var indexOfFirstInSequence;
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this 
                        //   node is a standard one sandwiched between two element nodes. 
                        if (prevNodeWasTextNode) {
                            indexOfTextNode = indexOfFirstInSequence;
                        }
                        else {
                            indexOfTextNode = index;
                        }
                        
                        // Break out of .each loop
                        return false; 
                    }

                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
                    prevNodeWasTextNode = true;
                    if (!indexOfFirstInSequence) {
                        indexOfFirstInSequence = index;
                    }
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                    indexOfFirstInSequence = undefined;
                }
            }
        );

        // Convert the text node index to a CFI odd-integer representation
        CFIIndex = (indexOfTextNode * 2) + 1;

        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
        //   been temporarily removed. 

        // Add pre- and post- text assertions
        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

        // textLength = $startTextNode[0].nodeValue.length;
        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

        // Gotta infer the correct character offset, as well

        // Return the constructed CFI text node step
        return "/" + CFIIndex + ":" + characterOffset;
         // + "[" + preAssertion + "," + postAssertion + "]";
    },

    // Description: A set of adjacent text nodes can be inferred to have been a single text node in the original document. As such, 
    //   if the character offset is specified for one of the adjacent text nodes, the true offset for the original node must be
    //   inferred.
    findOriginalTextNodeCharOffset : function ($startTextNode, specifiedCharacterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var textLength;
        
        // Find text node position in the set of child elements, ignoring any cfi markers 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node number in the list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var originalCharOffset = -1; // So the character offset is a 0-based index; we'll be adding lengths of text nodes to this number
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        if (prevNodeWasTextNode) {
                            originalCharOffset = originalCharOffset + specifiedCharacterOffset;
                        }
                        else {
                            originalCharOffset = specifiedCharacterOffset;
                        }

                        return false; // Break out of .each loop
                    }
                    else {

                        originalCharOffset = originalCharOffset + this.length;
                    }

                    // save this index as the first in sequence of adjacent text nodes, if not set
                    prevNodeWasTextNode = true;
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                }
            }
        );

        return originalCharOffset;
    },

    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

        var $blacklistExcluded;
        var $parentNode;
        var currNodePosition;
        var CFIPosition;
        var idAssertion;
        var elementStep; 

        // Find position of current node in parent list
        $blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
        $.each($blacklistExcluded, 
            function (index, value) {

                if (this === $currNode[0]) {

                    currNodePosition = index;

                    // Break loop
                    return false;
                }
        });

        // Convert position to the CFI even-integer representation
        CFIPosition = (currNodePosition + 1) * 2;

        // Create CFI step with id assertion, if the element has an id
        if ($currNode.attr("id")) {
            elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
        }
        else {
            elementStep = "/" + CFIPosition;
        }

        // If a parent is an html element return the (last) step for this content document, otherwise, continue.
        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the
        //   top level element.
        $parentNode = $currNode.parent();
        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {
            
            // If the top level node is a type from which an indirection step, add an indirection step character (!)
            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do
            //   not return an indirection character. Every other type of top-level element may require an indirection
            //   step to navigate to, thus requiring that ! is always prepended. 
            if (topLevelElement === 'html') {
                return "!" + elementStep;
            }
            else {
                return elementStep;
            }
        }
        else {
            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
        }
    }
};

    var interpreter = EPUBcfi.Interpreter;
    var generator = EPUBcfi.Generator;
    var instructions = EPUBcfi.CFIInstructions;

    // The public interface
    return {

        getContentDocHref : function (CFI, packageDocument) { return interpreter.getContentDocHref.call(interpreter, CFI, packageDocument); },
        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) { return interpreter.injectElement.call(interpreter, CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist); },
        getTargetElement : function (CFI, contentDocument) { return interpreter.getTargetElement.call(interpreter, CFI, contentDocument); },
        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument) { return interpreter.getTargetElementWithPartialCFI.call(interpreter, contentDocumentCFI, contentDocument); },
        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument) { return interpreter.getTextTerminusInfoWithPartialCFI.call(interpreter, contentDocumentCFI, contentDocument); }, 
        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset) { return generator.generateCharacterOffsetCFIComponent.call(generator, startTextNode, characterOffset); },
        generateElementCFIComponent : function (startElement) { return generator.generateElementCFIComponent.call(generator, startElement); },
        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument) { return generator.generatePackageDocumentCFIComponent.call(generator, contentDocumentName, packageDocument); },
        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument) { return generator.generatePackageDocumentCFIComponentWithSpineIndex.call(generator, spineIndex, packageDocument); },
        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) { return generator.generateCompleteCFI.call(generator, packageDocumentCFIComponent, contentDocumentCFIComponent); },
        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) { return instructions.injectCFIMarkerIntoText.call(instructions, $textNodeList, textOffset, elementToInject); },
        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.injectRangeElements.call(interpreter, rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);
        },
        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {
            return interpreter.getRangeTargetElements.call(interpreter, rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateCharOffsetRangeComponent.call(generator, rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);
        },
        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {
            return generator.generateElementRangeComponent.call(generator, rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);
        }
    };
};

    var EpubReflowableModule = function(spineObject, viewerSettingsObject, CFIAnnotations, bindings) {
    
    var EpubReflowable = {};

    // Rationale: The order of these matters
    // Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

EpubReflowable.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});
    EpubReflowable.ReflowableAnnotations = Backbone.Model.extend({

    defaults : {
        "saveCallback" : undefined,
        "callbackContext" : undefined
    },

    initialize : function (attributes, options) {
        this.epubCFI = new EpubCFIModule();
        // this.annotations = new EpubAnnotationsModule(0, 0, $("html", this.get("contentDocumentDOM"))[0]);
    },

    // Not sure about this, might remove it. The callbacks are unnecessary
    saveAnnotation : function (CFI, spinePosition) {

        var saveAnnotation = this.get("saveCallback");
        saveAnnotation.call(this.get("callbackContext"), CFI, spinePosition);
    },

    redraw : function () {

        // var leftAddition = -this.getPaginationLeftOffset();
        // this.annotations.redrawAnnotations(0, leftAddition);
    },

    // addHighlight : function (CFI, id) {

    //     var CFIRangeInfo;
    //     var range;
    //     var rangeStartNode;
    //     var rangeEndNode;
    //     var selectedElements;
    //     var leftAddition;
    //     var startMarkerHtml = this.getRangeStartMarker(CFI, id);
    //     var endMarkerHtml = this.getRangeEndMarker(CFI, id);

    //     try {
    //         CFIRangeInfo = this.epubCFI.injectRangeElements(
    //             CFI,
    //             this.get("contentDocumentDOM"),
    //             startMarkerHtml,
    //             endMarkerHtml,
    //             ["cfi-marker"]
    //             );

    //         // Get start and end marker for the id, using injected into elements
    //         // REFACTORING CANDIDATE: Abstract range creation to account for no previous/next sibling, for different types of
    //         //   sibiling, etc. 
    //         rangeStartNode = CFIRangeInfo.startElement.nextSibling ? CFIRangeInfo.startElement.nextSibling : CFIRangeInfo.startElement;
    //         rangeEndNode = CFIRangeInfo.endElement.previousSibling ? CFIRangeInfo.endElement.previousSibling : CFIRangeInfo.endElement;
    //         range = document.createRange();
    //         range.setStart(rangeStartNode, 0);
    //         range.setEnd(rangeEndNode, rangeEndNode.length);

    //         selectionInfo = this.getSelectionInfo(range);
    //         leftAddition = -this.getPaginationLeftOffset();
    //         this.annotations.addHighlight(CFI, selectionInfo.selectedElements, id, 0, leftAddition);

    //         return {
    //             CFI : CFI, 
    //             selectedElements : selectionInfo.selectedElements
    //         };

    //     } catch (error) {
    //         console.log(error.message);
    //     }
    // },

    // addBookmark : function (CFI, id) {

    //     var selectedElements;
    //     var bookmarkMarkerHtml = this.getBookmarkMarker(CFI, id);
    //     var $injectedElement;
    //     var leftAddition;

    //     try {
    //         $injectedElement = this.epubCFI.injectElement(
    //             CFI,
    //             this.get("contentDocumentDOM"),
    //             bookmarkMarkerHtml,
    //             ["cfi-marker"]
    //             );

    //         // Add bookmark annotation here
    //         leftAddition = -this.getPaginationLeftOffset();
    //         this.annotations.addBookmark(CFI, $injectedElement[0], id, 0, leftAddition);

    //         return {

    //             CFI : CFI, 
    //             selectedElements : $injectedElement[0]
    //         };

    //     } catch (error) {
    //         console.log(error.message);
    //     }
    // },

    // addSelectionHighlight : function (id) {

    //     var highlightRange;
    //     var selectionInfo;
    //     var leftAddition;
    //     var currentSelection = this.getCurrentSelectionRange();
    //     if (currentSelection) {

    //         highlightRange = this.injectHighlightMarkers(currentSelection);
    //         selectionInfo = this.getSelectionInfo(highlightRange);
    //         leftAddition = -this.getPaginationLeftOffset();
    //         this.annotations.addHighlight(selectionInfo.CFI, selectionInfo.selectedElements, id, 0, leftAddition);
    //         return selectionInfo;
    //     }
    //     else {
    //         throw new Error("Nothing selected");
    //     }
    // },

    // addSelectionBookmark : function (id) {

    //     var marker;
    //     var partialCFI;
    //     var leftAddition;
    //     var currentSelection = this.getCurrentSelectionRange();
    //     if (currentSelection) {

    //         partialCFI = this.generateCharOffsetCFI(currentSelection);
    //         marker = this.injectBookmarkMarker(currentSelection);
    //         leftAddition = -this.getPaginationLeftOffset();
    //         this.annotations.addBookmark("", marker, id, 0, leftAddition);

    //         return {
    //             CFI : partialCFI,
    //             selectedElements : marker
    //         };
    //     }
    //     else {
    //         throw new Error("Nothing selected");
    //     }
    // },

    // getSelectionInfo : function (selectedRange) {

    //     // Generate CFI for selected text
    //     var CFI = this.generateRangeCFI(selectedRange);
    //     var intervalState = {
    //         startElementFound : false,
    //         endElementFound : false
    //     };
    //     var selectedElements = [];

    //     this.findSelectedElements(
    //         selectedRange.commonAncestorContainer, 
    //         selectedRange.startContainer, 
    //         selectedRange.endContainer,
    //         intervalState,
    //         selectedElements, 
    //         "p"
    //         );

    //     // Return a list of selected text nodes and the CFI
    //     return {
    //         CFI : CFI,
    //         selectedElements : selectedElements
    //     };
    // },

    // generateRangeCFI : function (selectedRange) {

    //     var startNode = selectedRange.startContainer;
    //     var endNode = selectedRange.endContainer;
    //     var startOffset;
    //     var endOffset;
    //     var rangeCFIComponent;

    //     if (startNode.nodeType === Node.TEXT_NODE && endNode.nodeType === Node.TEXT_NODE) {

    //         startOffset = selectedRange.startOffset;
    //         endOffset = selectedRange.endOffset;

    //         rangeCFIComponent = this.epubCFI.generateCharOffsetRangeComponent(startNode, startOffset, endNode, endOffset);
    //         return rangeCFIComponent;
    //     }
    //     else {
    //         throw new Error("Selection start and end must be text nodes");
    //     }
    // },

    // generateCharOffsetCFI : function (selectedRange) {

    //     // Character offset
    //     var startNode = selectedRange.startContainer;
    //     var startOffset = selectedRange.startOffset;
    //     var charOffsetCFI;

    //     if (startNode.nodeType === Node.TEXT_NODE) {
    //         charOffsetCFI = this.epubCFI.generateCharacterOffsetCFIComponent(
    //             startNode,
    //             startOffset,
    //             ["cfi-marker"]
    //             );
    //     }
    //     return charOffsetCFI;
    // },

    findExistingLastPageMarker : function ($visibleTextNode) {

        // Check if a last page marker already exists on this page
        try {
            
            var existingCFI = undefined;
            $.each($visibleTextNode.parent().contents(), function () {

                if ($(this).hasClass("last-page")) {
                    lastPageMarkerExists = true;
                    existingCFI = $(this).attr("data-last-page-cfi");

                    // Break out of loop
                    return false;
                }
            });

            return existingCFI;
        }
        catch (e) {

            console.log("Could not generate CFI for non-text node as first visible element on page");

            // No need to execute the rest of the save position method if the first visible element is not a text node
            return undefined;
        }
    },

    // REFACTORING CANDIDATE: Convert this to jquery
    findSelectedElements : function (currElement, startElement, endElement, intervalState, selectedElements, elementTypes) {

        if (currElement === startElement) {
            intervalState.startElementFound = true;
        }

        if (intervalState.startElementFound === true) {
            this.addElement(currElement, selectedElements, elementTypes);
        }

        if (currElement === endElement) {
            intervalState.endElementFound = true;
            return;
        }

        if (currElement.firstChild) {
            this.findSelectedElements(currElement.firstChild, startElement, endElement, intervalState, selectedElements, elementTypes);
            if (intervalState.endElementFound) {
                return;
            }
        }

        if (currElement.nextSibling) {
            this.findSelectedElements(currElement.nextSibling, startElement, endElement, intervalState, selectedElements, elementTypes);
            if (intervalState.endElementFound) {
                return;
            }
        }
    },

    addElement : function (currElement, selectedElements, elementTypes) {

        // Check if the node is one of the types
        if (currElement.nodeType === Node.TEXT_NODE) {
            selectedElements.push(currElement);
        }
    },

    // REFACTORING CANDIDATE: The methods here inject bookmark/highlight markers for the current selection, after
    //   which information for the selected range is generated and returned in an annotation "info" object. The 
    //   injectedHighlightMarkers method leverages parts of the CFI library that should be private to that library; this
    //   is not ideal, and adds redundant, complex, code to the annotations delegate. A better method here would be to generate
    //   selection info, get the generated range CFI, and use that to inject markers. The only reason this wasn't done is 
    //   because the CFI library did not support CFI range generation or injection when selection and highlighting was done.
    // injectBookmarkMarker : function (selectionRange, id) {

    //     var startNode = selectionRange.startContainer;
    //     var startOffset = selectionRange.startOffset;
    //     var $bookmarkMarker = $(this.getBookmarkMarker("", id));
    //     var highlightRange;

    //     this.epubCFI.injectElementAtOffset(
    //         $(startNode), 
    //         startOffset,
    //         $bookmarkMarker
    //     );

    //     return $bookmarkMarker[0];        
    // },
 
    // injectHighlightMarkers : function (selectionRange, id) {

    //     var highlightRange;
    //     if (selectionRange.startContainer === selectionRange.endContainer) {
    //         highlightRange = this.injectHighlightInSameNode(selectionRange, id);
    //     } else {
    //         highlightRange = this.injectHighlightsInDifferentNodes(selectionRange, id);
    //     }

    //     return highlightRange;
    // },

    // injectHighlightInSameNode : function (selectionRange, id) {

    //     var startNode;
    //     var startOffset = selectionRange.startOffset;
    //     var endNode = selectionRange.endContainer;
    //     var endOffset = selectionRange.endOffset;
    //     var $startMarker = $(this.getRangeStartMarker("", id));
    //     var $endMarker = $(this.getRangeEndMarker("", id));
    //     var highlightRange;

    //     // Rationale: The end marker is injected before the start marker because when the text node is split by the 
    //     //   end marker first, the offset for the start marker will still be the same and we do not need to recalculate 
    //     //   the offset for the newly created end node.

    //     // inject end marker
    //     this.epubCFI.injectElementAtOffset(
    //         $(endNode), 
    //         endOffset,
    //         $endMarker
    //     );

    //     startNode = $endMarker[0].previousSibling;

    //     // inject start marker
    //     this.epubCFI.injectElementAtOffset(
    //         $(startNode), 
    //         startOffset,
    //         $startMarker
    //     );

    //     // reconstruct range
    //     highlightRange = document.createRange();
    //     highlightRange.setStart($startMarker[0].nextSibling, 0);
    //     highlightRange.setEnd($endMarker[0].previousSibling, $endMarker[0].previousSibling.length - 1);

    //     return highlightRange;
    // },

    // injectHighlightsInDifferentNodes : function (selectionRange, id) {

    //     var startNode = selectionRange.startContainer;
    //     var startOffset = selectionRange.startOffset;
    //     var endNode = selectionRange.endContainer;
    //     var endOffset = selectionRange.endOffset;
    //     var $startMarker = $(this.getRangeStartMarker("", id));
    //     var $endMarker = $(this.getRangeEndMarker("", id));
    //     var highlightRange;

    //     // inject start
    //     this.epubCFI.injectElementAtOffset(
    //         $(startNode), 
    //         startOffset,
    //         $startMarker
    //     );

    //     // inject end
    //     this.epubCFI.injectElementAtOffset(
    //         $(endNode), 
    //         endOffset,
    //         $endMarker
    //     );

    //     // reconstruct range
    //     highlightRange = document.createRange();
    //     highlightRange.setStart($startMarker[0].nextSibling, 0);
    //     highlightRange.setEnd($endMarker[0].previousSibling, $endMarker[0].previousSibling.length - 1);

    //     return highlightRange;
    // },

    // Rationale: This is a cross-browser method to get the currently selected text
    getCurrentSelectionRange : function () {

        var currentSelection;
        var iframeDocument = this.get("contentDocumentDOM");
        if (iframeDocument.getSelection) {
            currentSelection = iframeDocument.getSelection();

            if (currentSelection.rangeCount) {
                return currentSelection.getRangeAt(0);
            }
        }
        else if (iframeDocument.selection) {
            return iframeDocument.selection.createRange();
        }
        else {
            return undefined;
        }
    },

    getPaginationLeftOffset : function () {

        var $htmlElement = $("html", this.get("contentDocumentDOM"));
        var offsetLeftPixels = $htmlElement.css("left");
        var offsetLeft = parseInt(offsetLeftPixels.replace("px", ""));
        return offsetLeft;
    },

    getBookmarkMarker : function (CFI, id) {

        return "<span class='bookmark-marker cfi-marker' id='" + id + "' data-cfi='" + CFI + "'></span>";
    },

    getRangeStartMarker : function (CFI, id) {

        return "<span class='range-start-marker cfi-marker' id='start-" + id + "' data-cfi='" + CFI + "'></span>";
    },

    getRangeEndMarker : function (CFI, id) {

        return "<span class='range-end-marker cfi-marker' id='end-" + id + "' data-cfi='" + CFI + "'></span>";
    }
});

    
EpubReflowable.ReflowableElementInfo = Backbone.Model.extend({

    initialize : function () {},

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    getElemPageNumber: function(elem, offsetDir, pageWidth, gapWidth, epubContentDocument) {
        
        var $elem;
        var elemWasInvisible = false;
        var rects, shift;
        var elemRectWidth;

        // Rationale: Elements with an epub:type="pagebreak" attribute value are likely to be set as 
        //   display:none, as they indicate the end of a page in the corresponding physical version of a book. We need 
        //   the position of these elements to get the reflowable page number to set in the viewer. Therefore, 
        //   we check if the element has this epub:type value, set it visible, find its location and then set it to 
        //   display:none again. 
        // REFACTORING CANDIDATE: We might want to do this for any element with display:none. 
        $elem = $(elem);
        if ($elem.attr("epub:type") === "pagebreak" && !$elem.is(":visible")) {

            elemWasInvisible = true;
            $elem.show();
        }

        rects = elem.getClientRects();
        if(!rects || rects.length < 1) {
            // if there were no rects the elem had display none
            return -1;
        }

        shift = rects[0][offsetDir];

        // calculate to the center of the elem
        // Rationale: The -1 or +1 adjustment is to account for the case in which the target element for which the shift offset
        //   is calculated is at the edge of a page and has 0 width. In this case, if a minor arbitrary adjustment is not applied, 
        //   the calculated page number will be off by 1.   
        elemRectWidth = rects[0].left - rects[0].right;
        if (offsetDir === "right" && elemRectWidth === 0) {
            shift -= 1;
        }
        else if (offsetDir === "left" && elemRectWidth === 0) {
            shift += 1;
        } // Rationale: There shouldn't be any other case here. The explict second (if else) condition is for clarity.
        shift += Math.abs(elemRectWidth);
        
        // Re-hide the element if it was original set as display:none
        if (elemWasInvisible) {
            $elem.hide();
        }

        // `clientRects` are relative to the top left corner of the frame, but
        // for right to left we actually need to measure relative to right edge
        // of the frame
        if (offsetDir === "right") {
            // the right edge is exactly `this.page_width` pixels from the right 
            // edge
            shift = pageWidth - shift;
        }
        // less the amount we already shifted to get to cp
        shift -= parseInt(epubContentDocument.style[offsetDir], 10); 
        return Math.ceil( shift / (pageWidth + gapWidth) );
    },

    getElemPageNumberById: function(elemId, epubContentDocument, offsetDir, pageWidth, gapWidth) {

        var elem = $(epubContentDocument).find("#" + elemId);
        if (elem.length == 0) {
            return -1;
        }
        else {
            return this.getElemPageNumber(elem[0], offsetDir, pageWidth, gapWidth, epubContentDocument);
        }
    },

    // Currently for left-to-right pagination only
    findVisibleCharacterOffset : function($textNode, epubContentDocument) {

        var $parentNode;
        var elementTop;
        var elementBottom;
        var POSITION_ERROR_MARGIN = 5;
        var $document;
        var documentTop;
        var documentBottom;
        var percentOfTextOffPage;
        var characterOffset;

        // Get parent; text nodes do not have visibility properties.
        $parentNode = $textNode.parent();

        // Get document
        $document = $(epubContentDocument);

        // Find percentage of visible node on page
        documentTop = $document.position().top;
        documentBottom = documentTop + $document.height();

        elementTop = $parentNode.offset().top;
        elementBottom = elementTop + $parentNode.height();

        // Element overlaps top of the page
        if (elementTop < documentTop) {

            percentOfTextOffPage = Math.abs(elementTop - documentTop) / $parentNode.height();
            characterOffsetByPercent = Math.ceil(percentOfTextOffPage * $textNode[0].length);
            characterOffset = Math.ceil(0.5 * ($textNode[0].length - characterOffsetByPercent)) + characterOffsetByPercent;
        }
        // Element is full on the page
        else if (elementTop >= documentTop && elementTop <= documentBottom) {
            characterOffset = 1;
        }
        // Element overlaps bottom of the page
        else if (elementTop < documentBottom) {
            characterOffset = 1;
        }

        return characterOffset;
    },

    // TODO: Extend this to be correct for right-to-left pagination
    findVisibleTextNode: function (epubContentDocument, isTwoUp, columnGap, columnWidth) {

        var documentLeft = 0;
        var documentRight;
        var doc;
        var $elements;
        var $firstVisibleTextNode;

        // Rationale: The intention here is to get a list of all the text nodes in the document, after which we'll
        //   reduce this to the subset of text nodes that is visible on the page. We'll then select one text node
        //   for which we can create a character offset CFI. This CFI will then refer to a "last position" in the 
        //   EPUB, which can be used if the reader re-opens the EPUB.
        // REFACTORING CANDIDATE: The "audiError" check is a total hack to solve a problem for a particular epub. This 
        //   issue needs to be addressed.
        $elements = $("body", epubContentDocument).find(":not(iframe)").contents().filter(function () {
            if (this.nodeType === 3 && !$(this).parent().hasClass("audiError")) {
                return true;
            } else {
                return false;
            }
        });

        doc = epubContentDocument;

        if (isTwoUp) {
            documentRight = documentLeft + columnGap + (columnWidth * 2);
        } 
        else {
            documentRight = documentLeft + $(doc).width();
        }

        // Find the first visible text node 
        $.each($elements, function() {

            var POSITION_ERROR_MARGIN = 5;
            var $textNodeParent = $(this).parent();
            var elementLeft = $textNodeParent.position().left;
            var elementRight = elementLeft + $textNodeParent.width();
            var nodeText;

            // Correct for minor right and left position errors
            elementLeft = Math.abs(elementLeft) < POSITION_ERROR_MARGIN ? 0 : elementLeft;
            elementRight = Math.abs(elementRight - documentRight) < POSITION_ERROR_MARGIN ? documentRight : elementRight;

            // Heuristics to find a text node with actual text
            nodeText = this.nodeValue.replace(/\n/g, "");
            nodeText = nodeText.replace(/ /g, "");

            if (elementLeft <= documentRight 
                && elementRight >= documentLeft
                && nodeText.length > 10) { // 10 is so the text node is actually a text node with writing - probably

                $firstVisibleTextNode = $(this);

                // Break the loop
                return false;
            }
        });

        return $firstVisibleTextNode;
    },

    findVisiblePageElements: function(flowingWrapper, epubContentDocument) {

        var $elements = $(epubContentDocument).find("[id]");
        var doc = epubContentDocument;
        var doc_top = 0;
        var doc_left = 0;
        var doc_right = doc_left + $(doc).width();
        var doc_bottom = doc_top + $(doc).height();
        
        var visibleElms = this.filterElementsByPosition(flowingWrapper, $elements, doc_top, doc_bottom, doc_left, doc_right);
            
        return visibleElms;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    // returns all the elements in the set that are inside the box
    filterElementsByPosition: function(flowingWrapper, $elements, documentTop, documentBottom, documentLeft, documentRight) {
        
        var $visibleElms = $elements.filter(function(idx) {
            var elm_top = $(flowingWrapper).offset().top;
            var elm_left = $(flowingWrapper).offset().left;
            var elm_right = elm_left + $(flowingWrapper).width();
            var elm_bottom = elm_top + $(flowingWrapper).height();
            
            var is_ok_x = elm_left >= documentLeft && elm_right <= documentRight;
            var is_ok_y = elm_top >= documentTop && elm_bottom <= documentBottom;
            
            return is_ok_x && is_ok_y;
        });  

        return $visibleElms;
    }
});
    // REFACTORING CANDIDATE: Need a better name for this
EpubReflowable.ReflowableLayout = Backbone.Model.extend({

    initialize: function (options) {
        // make sure we have proper vendor prefixed props for when we need them
    },

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initializeContentDocument : function (epubContentDocument, epubCFIs, currSpinePosition, readiumFlowingContent, linkClickHandler, handlerContext, currentTheme, flowingWrapper, readiumFlowingContent, keydownHandler, bindings) {

        var triggers;
        var lastPageElementId = this.injectCFIElements(
            epubContentDocument, 
            epubCFIs, 
            currSpinePosition
            );

        // this.applyBindings( readiumFlowingContent, epubContentDocument );
        this.applySwitches( epubContentDocument, readiumFlowingContent ); 
        // this.injectMathJax(epubContentDocument);
        this.injectLinkHandler(epubContentDocument, linkClickHandler, handlerContext);
        triggers = this.parseTriggers(epubContentDocument);
        this.applyTriggers(epubContentDocument, triggers);
        $(epubContentDocument).attr('title');//, Acc.page + ' - ' + Acc.title);

        this.injectTheme(
            currentTheme, 
            epubContentDocument, 
            flowingWrapper
        );

        this.injectKeydownHandler(
            readiumFlowingContent, 
            keydownHandler, 
            handlerContext
        );

        return lastPageElementId;
    },

    injectTheme : function (currentTheme, epubContentDocument, flowingWrapper) {

        var theme = currentTheme;
        if (theme === "default") {
            theme = "default-theme";
        }

        $(epubContentDocument).css({
            "color": this.themes[theme]["color"],
            "background-color": this.themes[theme]["background-color"]
        });
        
        // stop flicker due to application for alternate style sheets
        // just set content to be invisible
        $(flowingWrapper).css("visibility", "hidden");
        this.activateEPubStyle(epubContentDocument, currentTheme);

        // wait for new stylesheets to parse before setting back to visible
        setTimeout(function() {
            $(flowingWrapper).css("visibility", "visible"); 
        }, 100);
    },

    resetEl : function (epubContentDocument, flowingWrapper, spineDivider, zoomer) {

        $("body", epubContentDocument).removeClass("apple-fixed-layout");
        $(flowingWrapper).attr("style", "");
        $(flowingWrapper).toggleClass("two-up", false);
        $(spineDivider).toggle(false);
        // zoomer.reset();

        $(flowingWrapper).css({
            "position": "relative",
            "right": "0px", 
            "top": "0px",
            "-webkit-transform": "scale(1.0) translate(0px, 0px)"
        });
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE HELPERS                                                                     //
    // ------------------------------------------------------------------------------------ //

    // Description: Activates a style set for the ePub, based on the currently selected theme. At present, 
    //   only the day-night alternate tags are available as an option.  
    activateEPubStyle : function (bookDom, currentTheme) {

        var selector;
        
        // Apply night theme for the book; nothing will be applied if the ePub's style sheets do not contain a style
        // set with the 'night' tag
        if (currentTheme === "night-theme") {

            selector = new EpubReflowable.AlternateStyleTagSelector;
            bookDom = selector.activateAlternateStyleSet(["night"], bookDom);

        }
        else {

            selector = new EpubReflowable.AlternateStyleTagSelector;
            bookDom = selector.activateAlternateStyleSet([""], bookDom);
        }
    },

    injectCFIElements : function (epubContentDocument, epubCFIs, currSpinePosition) {

        var that = this;
        var contentDocument;
        var epubCFIs;
        var lastPageElementId;

        // Get the content document (assumes a reflowable publication)
        contentDocument = epubContentDocument;

        // TODO: Could check to make sure the document returned from the iframe has the same name as the 
        //   content document specified by the href returned by the CFI.

        // Inject elements for all the CFIs that reference this content document
        epubCFIs = epubCFIs; // What is this about? 
        _.each(epubCFIs, function (cfi, key) {

            if (cfi.contentDocSpinePos === currSpinePosition) {

                try {
                    
                    EPUBcfi.Interpreter.injectElement(
                        key,
                        contentDocument.parentNode,
                        cfi.payload,
                        ["cfi-marker", "audiError"],
                        [],
                        ["MathJax_Message"]);

                    if (cfi.type === "last-page") {
                        lastPageElementId = $(cfi.payload).attr("id");
                    }
                } 
                catch (e) {

                    console.log("Could not inject CFI");
                }
            }
        });

        // This will be undefined unless there is a "last-page" element injected into the page
        return lastPageElementId;
    },

    // // REFACTORING CANDIDATE: It looks like this could go on the package document itself
    // getBindings: function (packageDocument) {
    //     var packDoc = packageDocument;
    //     var bindings = packDoc.get('bindings');
    //     return bindings.map(function(binding) {
    //         binding.selector = 'object[type="' + binding.media_type + '"]';
    //         binding.url = packDoc.getManifestItemById(binding.handler).get('href');
    //         binding.url = packDoc.resolveUri(binding.url);
    //         return binding;
    //     })
    // },

    // Binding expected by this:
    //   binding.selector
    //   binding.url
    //   binding.media_type
    // applyBindings: function (readiumFlowingContent, epubContentDocument, bindings) {

    //     var bindingHtml = "<iframe scrolling='no' \
    //                             frameborder='0' \
    //                             marginwidth='0' \
    //                             marginheight='0' \
    //                             width='100%' \
    //                             height='100%' \
    //                             class='binding-sandbox'> \
    //                        </iframe>";

    //     // var bindings = this.getBindings(packageDocument);
    //     var i = 0;
    //     for(var i = 0; i < bindings.length; i++) {
    //         $(bindings[i].selector, epubContentDocument.parentNode).each(function() {
    //             var params = [];
    //             var $el = $(readiumFlowingContent);
    //             var data = $el.attr('data');
    //             var url;
    //             // params.push("src=" + packageDocument.resolveUri(data)); // Not sure what this is doing
    //             params.push('type=' + bindings[i].media_type);
    //             url = bindings[i].url + "?" + params.join('&');
    //             // var content = $(bindingTemplate({}));
    //             var content = $(bindingHtml);
    //             // must set src attr separately
    //             content.attr('src', url);
    //             $el.html(content);
    //         });
    //     }
    // },

    applyTriggers: function (epubContentDocument, triggers) {
        for(var i = 0 ; i < triggers.length; i++) {
            triggers[i].subscribe(epubContentDocument.parentNode);
        }
    },

    // Description: For reflowable content we only add what is in the body tag.
    //   Lots of times the triggers are in the head of the dom
    parseTriggers: function (epubContentDocument) {
        var triggers = [];
        $('trigger', epubContentDocument.parentNode).each(function() {
            
            triggers.push(new EpubReflowable.Trigger(epubContentDocument.parentNode) );
        });
        
        return triggers;
    },

    // Description: Parse the epub "switch" tags and hide
    //   cases that are not supported
    applySwitches: function (epubContentDocument, readiumFlowingContent) {

        // helper method, returns true if a given case node
        // is supported, false otherwise
        var isSupported = function(caseNode) {

            var ns = caseNode.attributes["required-namespace"];
            if(!ns) {
                // the namespace was not specified, that should
                // never happen, we don't support it then
                console.log("Encountered a case statement with no required-namespace");
                return false;
            }
            // all the xmlns's that readium is known to support
            // TODO this is going to require maintanence
            var supportedNamespaces = ["http://www.w3.org/1998/Math/MathML"];
            return _.include(supportedNamespaces, ns);
        };

        $('switch', epubContentDocument.parentNode).each(function(ind) {
            
            // keep track of whether or now we found one
            var found = false;

            $('case', readiumFlowingContent).each(function() {

                if( !found && isSupported(readiumFlowingContent) ) {
                    found = true; // we found the node, don't remove it
                }
                else {
                    $(readiumFlowingContent).remove(); // remove the node from the dom
                }
            });

            if(found) {
                // if we found a supported case, remove the default
                $('default', readiumFlowingContent).remove();
            }
        })
    },

    // inject mathML parsing code into an iframe
    injectMathJax: function (epubContentDocument) {

        var doc, script, head;
        doc = epubContentDocument.parentNode;
        head = doc.getElementsByTagName("head")[0];
        // if the content doc is SVG there is no head, and thus
        // mathjax will not be required
        if(head) {
            script = doc.createElement("script");
            script.type = "text/javascript";
            script.src = MathJax.Hub.config.root+"/MathJax.js?config=readium-iframe";
            head.appendChild(script);
        }
    },

    injectLinkHandler: function (epubContentDocument, linkClickHandler, handlerContext) {

        $('a', epubContentDocument).click(function (e) {
            linkClickHandler.call(handlerContext, e);
        });
    },

    injectKeydownHandler : function (readiumFlowingContent, keydownHandler, handlerContext) {

        $(readiumFlowingContent).contents().keydown(function (e) {
            keydownHandler.call(handlerContext, e);
        });
    },

    // Rationale: sadly this is just a reprint of what is already in the
    //   themes stylesheet. It isn't very DRY but the implementation is
    //   cleaner this way
    themes: {
        "default-theme": {
            "background-color": "white",
            "color": "black",
            "mo-color": "#777"
        },

        "vancouver-theme": {
            "background-color": "#DDD",
            "color": "#576b96",
            "mo-color": "#777"
        },

        "ballard-theme": {
            "background-color": "#576b96",
            "color": "#DDD",
            "mo-color": "#888"
        },

        "parchment-theme": {
            "background-color": "#f7f1cf",
            "color": "#774c27",
            "mo-color": "#eebb22"
        },

        "night-theme": {
            "background-color": "#141414",
            "color": "white",
            "mo-color": "#666"
        }
    }
});
    // Description: This model is responsible determining page numbers to display for reflowable EPUBs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer.

EpubReflowable.ReflowablePageNumberLogic = Backbone.Model.extend({

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initialize: function () {},

    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //  )
    // REFACTORING CANDIDATE: This might be better named as getPageNumsToDisplay; the "goto" is confusing
    getGotoPageNumsToDisplay: function(gotoPageNumber, twoUp, firstPageOffset) {

        if (twoUp) {
            
            if (firstPageOffset) {

                // EVEN_PAGE |spine| ODD_PAGE
                if (gotoPageNumber % 2 === 1) {
                    return [gotoPageNumber - 1, gotoPageNumber];
                }
                else {
                    return [gotoPageNumber, gotoPageNumber + 1];
                }
            }
            else {
                // ODD_PAGE |spine| EVEN_PAGE
                if (gotoPageNumber % 2 === 1) {
                    return [gotoPageNumber, gotoPageNumber + 1];    
                } 
                else {
                    return [gotoPageNumber - 1, gotoPageNumber];
                }
            }   
        }
        else {  
            return [gotoPageNumber];
        }
    },

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
    //   prevPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //  )
    getPrevPageNumsToDisplay: function (prevPageNumberToDisplay) {

        return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
    },

    // Description: Get the pages to display when moving in reading order
    // Arguments (
    //   nextPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //  )
    getNextPageNumsToDisplay: function (nextPageNumberToDisplay) {

        return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
    },

    // Description: This method determines which page numbers to display when switching
    //   between a single page and side-by-side page views and vice versa.
    // Arguments (
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //   displayedPageNumbers (array of integers): An array of page numbers that are currently displayed    
    //   firstPageOffset: Is the first page of a reflowable EPUB offset, to create a blank page for the first page? 
    //  )
    getPageNumbersForTwoUp: function(twoUp, displayedPageNumbers, firstPageOffset) {

        var displayed = displayedPageNumbers;
        var twoPagesDisplayed = displayed.length === 2 ? true : false;
        var newPages = [];

        // Two pages are currently displayed; find the single page number to display
        if (twoPagesDisplayed) {

            // Rationale: I think this check is a bit of a hack, for the case in which a set of pages is [0, 1]. Pages are
            //   1-indexed, so the "0" in the 0 index position of the array is not valid.
            if (displayed[0] === 0) {
                newPages[0] = 1;
            } 
            else {
                newPages[0] = displayed[0];
            }
        }
        // A single reflowable page is currently displayed; find two pages to display
        else if (firstPageOffset) {

            if (displayed[0] % 2 === 1) {

                newPages[0] = displayed[0] - 1;
                newPages[1] = displayed[0];
            }
            else {

                newPages[0] = displayed[0];
                newPages[1] = displayed[0] + 1;
            }               
        }
        else {

            if (displayed[0] % 2 === 1) {
                
                newPages[0] = displayed[0];
                newPages[1] = displayed[0] + 1;
            }
            else {
                
                newPages[0] = displayed[0] - 1;
                newPages[1] = displayed[0];
            }
        }

        return newPages;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

});
    // REFACTORING CANDIDATE: You can infer whether the layout is one or two pages based on the length of the 
//   the current_page array. However, the possibility exists that this could become out of sync with the
//   viewer settings (this state would be maintained in two places). Perhaps better still that the paramater
//   is passed to the public methods? 

EpubReflowable.ReflowablePagination = Backbone.Model.extend({ 

    defaults: {
        "num_pages" : 0,
        "current_page" : [1]
    },

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    initialize: function () {

        // Instantiate an object responsible for deciding which pages to display
        this.pageNumberDisplayLogic = new EpubReflowable.ReflowablePageNumberLogic();
        
        // if content reflows and the number of pages in the section changes
        // we need to adjust the the current page
        // Probably a memory leak here, should add a destructor
        this.on("change:num_pages", this.adjustCurrentPage, this);
    },

    // Description: This method determines which page numbers to display when switching
    //   between a single page and side-by-side page views and vice versa.
    toggleTwoUp: function (twoUp, firstPageIsOffset) {

        // if (this.epubController.epub.get("can_two_up")) {

            var newPages = this.pageNumberDisplayLogic.getPageNumbersForTwoUp (
                twoUp, 
                this.get("current_page"),
                firstPageIsOffset
                );

            if (!twoUp) {
                newPages = this.adjustForMaxPageNumber(newPages);
            }

            this.set({current_page: newPages});
        // }   
    },

    // REFACTORING CANDIDATE: prevPage and nextPage are public but not sure it should be; it's called from the navwidget and viewer.js.
    //   Additionally the logic in this method, as well as that in nextPage(), could be refactored to more clearly represent that 
    //   multiple different cases involved in switching pages.
    prevPage: function(twoUp) {

        var previousPage = this.get("current_page")[0] - 1;

        // Single page navigation
        if (!twoUp){

            this.set("current_page", [previousPage]);
        }
        // Move to previous page with two side-by-side pages
        else {

            var pagesToDisplay = this.pageNumberDisplayLogic.getPrevPageNumsToDisplay(
                                previousPage
                                );
            this.set("current_page", pagesToDisplay);
        }
    },

    nextPage: function(twoUp) {

        var curr_pg = this.get("current_page");
        var firstPage = curr_pg[curr_pg.length - 1] + 1;

        // Single page is up
        if (!twoUp) {

            this.set("current_page", [firstPage]);
        }
        // Two pages are being displayed
        else {

            var pagesToDisplay = this.pageNumberDisplayLogic.getNextPageNumsToDisplay(
                                firstPage
                                );
            this.set("current_page", pagesToDisplay);
        }
    },

    goToPage: function(gotoPageNumber, twoUp, firstPageIsOffset) {

        var pagesToGoto = this.pageNumberDisplayLogic.getGotoPageNumsToDisplay(
                            gotoPageNumber,
                            twoUp,
                            firstPageIsOffset
                            );
        this.set("current_page", pagesToGoto);
    },

    // Description: Return true if the pageNum argument is a currently visible 
    //   page. Return false if it is not; which will occur if it cannot be found in 
    //   the array.
    isPageVisible: function(pageNum) {
        return this.get("current_page").indexOf(pageNum) !== -1;
    },

    // ------------------------------------------------------------------------------------ //  
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    adjustForMaxPageNumber : function (newPageNumbers) {

        var currentPages = this.get("current_page");
        var numberOfPages = this.get("num_pages");

        if (newPageNumbers[0] > numberOfPages) {
            return [numberOfPages];
        }
        else {
            return newPageNumbers;
        }
    }
});
    
EpubReflowable.ReflowablePaginator = Backbone.Model.extend({

    initialize: function (options) {
        // make sure we have proper vendor prefixed props for when we need them
    },

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    paginateContentDocument : function (spineDivider, isTwoUp, offsetDir, epubContentDocument, readiumFlowingContent, flowingWrapper, firstPageOffset, currentPages, ppd, currentMargin, fontSize) {

        this.toggleSyntheticLayout(
            flowingWrapper, 
            spineDivider, 
            isTwoUp
            );

        var page = this.adjustIframeColumns(
            offsetDir, 
            epubContentDocument, 
            readiumFlowingContent, 
            flowingWrapper, 
            isTwoUp, 
            firstPageOffset, 
            currentPages, 
            ppd, 
            currentMargin
            );

        var numPages = this.setFontSize(
            fontSize, 
            epubContentDocument, 
            isTwoUp
            );

        return [numPages, page];
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE HELPERS                                                                     //
    // ------------------------------------------------------------------------------------ //

    getColumnAxisCssName : function () {
        var columnAxisName = Modernizr.prefixed('columnAxis') || 'columnAxis';
        return this.createCssPropertyName(columnAxisName);
    },

    getColumnGapCssName : function () {
        var columnGapName = Modernizr.prefixed('columnGap') || 'columnGap';
        return this.createCssPropertyName(columnGapName);
    },

    getColumnWidthCssName : function () {
        var columnWidthName = Modernizr.prefixed('columnWidth') || 'columnWidth';
        return this.createCssPropertyName(columnWidthName);
    },

    createCssPropertyName : function (modernizrName) {

        return modernizrName.replace(/([A-Z])/g, function (modernizrName, m1) {  
            return '-' + m1.toLowerCase(); 
        }).replace(/^ms-/,'-ms-');
    },

    // ------------------------------------------------------------------------------------ //
    //  PRIVATE METHODS
    // ------------------------------------------------------------------------------------ //

    // Description: Changes the html to make either 1 or 2 pages visible in their iframes
    toggleSyntheticLayout : function (flowingWrapper, spineDivider, isTwoUp) {

        $(flowingWrapper).toggleClass("two-up", isTwoUp);
        $(spineDivider).toggle(isTwoUp);
    },

    // Description: calculate the number of pages in the current section,
    //   based on section length : page size ratio
    calcNumPages : function (epubContentDocument, isTwoUp, offsetDir) {

        var body, offset, width, num;
        
        // get a reference to the dom body
        body = epubContentDocument;

        // cache the current offset 
        offset = body.style[offsetDir];

        // set the offset to 0 so that all overflow is part of
        // the scroll width
        body.style[offsetDir] = "0px";

        // grab the scrollwidth => total content width
        width = epubContentDocument.scrollWidth;
        this.set("lastScrollWidth", width);

        // reset the offset to its original value
        body.style[offsetDir] = offset;

        // perform calculation and return result...
        num = Math.floor( (width + this.gap_width) / (this.gap_width + this.page_width) );

        // in two up mode, always set to an even number of pages
        if( num % 2 === 0 && isTwoUp) {
            //num += 1;
        }
        return num;
    },

    getFrameWidth : function (flowingWrapperWidth, currentMargin, isTwoUp) {

        var width;
        var margin = currentMargin;
        if (margin === 1) {
            isTwoUp ? (width = 0.95) : (width = 0.90);
        }
        else if (margin === 2) {
            isTwoUp ? (width = 0.89) : (width = 0.80);
        }
        else if (margin === 3) {
            isTwoUp ? (width = 0.83) : (width = 0.70); 
        }
        else if (margin === 4) {
            isTwoUp ? (width = 0.77) : (width = 0.60); 
        }
        else {
            isTwoUp ? (width = 0.70) : (width = 0.50); 
        }
        
        return Math.floor( flowingWrapperWidth * width );
    },

    // Rationale: on iOS frames are automatically expanded to fit the content dom
    //   thus we cannot use relative size for the iframe and must set abs 
    //   pixel size
    setFrameSize : function (flowingWrapperWidth, flowingWrapperHeight, readiumFlowingContent, currentMargin, isTwoUp) {

        var width = this.getFrameWidth(flowingWrapperWidth, currentMargin, isTwoUp).toString() + "px";
        var height = flowingWrapperHeight.toString() + "px"; 

        // Rationale: Set the width for both the iframe (epub content) and its parent. The parent width must be provided so 
        //   that the iframe content can be centered within it, using CSS (margin-left/right: auto; display:block)
        $(readiumFlowingContent).parent().css("width", width);
        $(readiumFlowingContent).parent().css("height", height);

        $(readiumFlowingContent).css("width", width);
        $(readiumFlowingContent).css("height", height);
    },

    getBodyColumnCss : function () {

        var css = {};
        css[this.getColumnAxisCssName()] = "horizontal";
        css[this.getColumnGapCssName()] = this.gap_width.toString() + "px";
        css[this.getColumnWidthCssName()] = this.page_width.toString() + "px";
        css["padding"] = "0px";
        css["margin"] = "0px";
        css["position"] = "absolute";
        css["width"] = this.page_width.toString() + "px";
        css["height"] = this.frame_height.toString() + "px";
        return css;
    },

    // Description: This method accounts for the case in which the page-spread-* property is set on the current 
    //   content document. When this property is set, it requires that the first page of content is offset by 1, 
    //   creating a blank page as the first page in a synthetic spread.
    accountForOffset : function (readiumFlowingContent, isTwoUp, firstPageIsOffset, currentPages, ppd) {

        var $reflowableIframe = $(readiumFlowingContent);

        if (isTwoUp) {
            // If the first page is offset, adjust the window to only show one page
            var firstPageIsOffset = firstPageIsOffset;
            var firstPageOffsetValue;

            // Rationale: A current page of [0, 1] indicates that the current display is synthetic, and that 
            //   only the first page should be showing in that display
            var onFirstPage = 
                currentPages[0] === 0 &&
                currentPages[1] === 1 
                ? true : false;

            if (firstPageIsOffset && onFirstPage) {

                if (ppd === "rtl") {

                    firstPageOffset = -(2 * (this.page_width + this.gap_width));
                    $reflowableIframe.css("margin-left", firstPageOffset + "px");
                }
                // Left-to-right pagination
                else {

                    firstPageOffset = this.page_width + (this.gap_width * 2);
                    $reflowableIframe.css("margin-left", firstPageOffset + "px");
                }

                return 1;
            }
            else {

                $reflowableIframe.css("margin-left", "0px");
                return currentPages[0];
            }
        }
        else {

            $reflowableIframe.css("margin-left", "0px");
            return currentPages[0];
        }
    },

    adjustIframeColumns : function (offsetDir, epubContentDocument, readiumFlowingContent, flowingWrapper, isTwoUp, firstPageOffset, currentPages, ppd, currentMargin ) {

        var prop_dir = offsetDir;
        var $frame = $(readiumFlowingContent);
        var page;

        // Rationale: Get width and height of the flowing wrapper parent, as the (application-specific) parent element dimensions are what the epub
        //   content should be sized to fit into.
        this.setFrameSize($(flowingWrapper).parent().width(), $(flowingWrapper).parent().height(), readiumFlowingContent, currentMargin, isTwoUp);

        this.frame_width = parseInt($frame.width(), 10);
        this.frame_height = parseInt($frame.height(), 10);
        this.gap_width = Math.floor(this.frame_width / 7);
        if (isTwoUp) {
            this.page_width = Math.floor((this.frame_width - this.gap_width) / 2);
        }
        else {
            this.page_width = this.frame_width;
        }

        // it is important for us to make sure there is no padding or
        // margin on the <html> elem, or it will mess with our column code
        $(epubContentDocument).css( this.getBodyColumnCss() );

        page = this.accountForOffset(readiumFlowingContent, isTwoUp, firstPageOffset, currentPages, ppd);
        return page;
    },

    setFontSize : function (fontSize, epubContentDocument, isTwoUp) {

        var size = fontSize / 10;
        $(epubContentDocument).css("font-size", size + "em");

        // the content size has changed so recalc the number of 
        // pages
        return this.calcNumPages(epubContentDocument, isTwoUp);
    }
});
    EpubReflowable.Trigger = function(domNode) {
	var $el = $(domNode);
	this.action 	= $el.attr("action");
	this.ref 		= $el.attr("ref");
	this.event 		= $el.attr("ev:event");
	this.observer 	= $el.attr("ev:observer");
	this.ref 		= $el.attr("ref");
};

EpubReflowable.Trigger.prototype.subscribe = function(dom) {
	var selector = "#" + this.observer;
	var that = this;
	$(selector, dom).on(this.event, function() {
		that.execute(dom);
	});
};

EpubReflowable.Trigger.prototype.execute = function(dom) {
	var $target = $( "#" + this.ref, dom);
	switch(this.action)
	{
	case "show":
	  $target.css("visibility", "visible");
	  break;
	case "hide":
	  $target.css("visibility", "hidden");
	  break;
	case "play":
	  $target[0].currentTime = 0;
	  $target[0].play();
	  break;
	case "pause":
	  $target[0].pause();
	  break;
	case "resume":
	  $target[0].play();
	  break;
	case "mute":
	  $target[0].muted = true;
	  break;
	case "unmute":
	  $target[0].muted = false;
	  break;
	default:
	  console.log("do not no how to handle trigger " + this.action);
	}
};
    // API: 
//  Methods that can be called when viewer settings change
//  Methods that can be called to do things, such as move to the next page, go to a hash fragment, etc.
//  Will probably also need to pass in a link click handler

EpubReflowable.ReflowablePaginationView = Backbone.View.extend({

    el : "<div class='flowing-wrapper clearfix' style='display:block;margin-left:auto;margin-right:auto'> \
            <iframe scrolling='no' \
                    frameborder='0' \
                    height='100%' \
                    class='readium-flowing-content'> \
            </iframe> \
            <div class='reflowing-spine-divider'></div> \
          </div>",

    // The spine json
    // Save annotation callback, context
    // EpubCFIs
    // Bindings
    // Viewer settings? 

	initialize : function (options) {

        var ViewerModel = Backbone.Model.extend({});
        var SpineItemModel = Backbone.Model.extend({});

        this.viewerModel = new ViewerModel(options.viewerSettings);
        this.viewerModel.set({ syntheticLayout : options.viewerSettings.syntheticLayout });
        this.spineItemModel = new SpineItemModel(options.spineItem);
        this.epubCFIs = options.contentDocumentCFIs;
        this.bindings = options.bindings;

		// Initalize delegates and other models
		this.reflowableLayout = new EpubReflowable.ReflowableLayout();
		this.reflowablePaginator = new EpubReflowable.ReflowablePaginator();
		this.reflowableElementsInfo = new EpubReflowable.ReflowableElementInfo();
		this.pages = new EpubReflowable.ReflowablePagination();

        // So this can be any callback, doesn't have to be the epub controller
		this.annotations;

        this.cfi = new EpubCFIModule();

        // this.mediaOverlayController = this.model.get("media_overlay_controller");
        // this.mediaOverlayController.setPages(this.pages);
        // this.mediaOverlayController.setView(this);

        // Initialize handlers
		// this.mediaOverlayController.on("change:mo_text_id", this.highlightText, this);
        // this.mediaOverlayController.on("change:active_mo", this.indicateMoIsPlaying, this);
		this.viewerModel.on("change:fontSize", this.rePaginationHandler, this);
		this.viewerModel.on("change:syntheticLayout", this.rePaginationHandler, this);
		this.viewerModel.on("change:currentMargin", this.rePaginationHandler, this);
		this.pages.on("change:current_page", this.pageChangeHandler, this);
		this.viewerModel.on("change:tocVisible", this.windowSizeChangeHandler, this);
		this.viewerModel.on("change:currentTheme", this.themeChangeHandler, this);
	},
	
	destruct : function() {
	
		// Remove all handlers so they don't hang around in memory	
		// this.mediaOverlayController.off("change:mo_text_id", this.highlightText, this);
  		// this.mediaOverlayController.off("change:active_mo", this.indicateMoIsPlaying, this);
		this.viewerModel.off("change:fontSize", this.rePaginationHandler, this);
		this.viewerModel.off("change:syntheticLayout", this.rePaginationHandler, this);
		this.viewerModel.off("change:currentMargin", this.rePaginationHandler, this);
		this.pages.off("change:current_page", this.pageChangeHandler, this);
		this.viewerModel.off("change:tocVisible", this.windowSizeChangeHandler, this);
		this.viewerModel.off("change:currentTheme", this.themeChangeHandler, this);

        this.reflowableLayout.resetEl(
        	this.getEpubContentDocument(), 
        	this.el, 
        	this.getSpineDivider());
	},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	render : function (goToLastPage, hashFragmentId) {

		var that = this;
		var json = this.spineItemModel.toJSON();

        $("iframe", this.el).attr("src", json.contentDocumentURI);
        $("iframe", this.el).attr("title", json.title);

		// Wait for iframe to load EPUB content document
		$(this.getReadiumFlowingContent()).on("load", function (e) {

			var lastPageElementId = that.initializeContentDocument();

			// Rationale: The content document must be paginated in order for the subsequent "go to page" methods
			//   to have access to the number of pages in the content document.
			that.paginateContentDocument();
			// that.mediaOverlayController.pagesLoaded();

			// Rationale: The assumption here is that if a hash fragment is specified, it is the result of Readium 
			//   following a clicked linked, either an internal link, or a link from the table of contents. The intention
			//   to follow a link should supersede restoring the last-page position, as this should only be done for the 
			//   case where Readium is re-opening the book, from the library view. 
			if (hashFragmentId) {
                that.goToHashFragment(hashFragmentId);
            }
            else if (lastPageElementId) {
                that.goToHashFragment(lastPageElementId);
            }
            else {

                if (goToLastPage) {
                    that.pages.goToLastPage(that.viewerModel.get("syntheticLayout"), that.spineItemModel.get("firstPageIsOffset"));
                }
                else {
                    that.pages.goToPage(1, that.viewerModel.get("syntheticLayout"), that.spineItemModel.get("firstPageIsOffset"));
                }
            }

            that.annotations = new EpubReflowable.ReflowableAnnotations({
                saveCallback : undefined,
                callbackContext : undefined,
                contentDocumentDOM : that.getEpubContentDocument().parentNode
            });

            that.trigger("contentDocumentLoaded", that.el);
		});
        
		return this.el;
	},
    
	// indicateMoIsPlaying: function () {
	// 	var moHelper = new EpubReflowable.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderReflowableMoPlaying(
	// 		this.model.get("current_theme"),
	// 		this.mediaOverlayController.get("active_mo"),
	// 		this
	// 	);
	// },

	// highlightText: function () {
	// 	var moHelper = new EpubReflowable.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderReflowableMoFragHighlight(
	// 		this.model.get("current_theme"),
	// 		this,
	// 		this.mediaOverlayController.get("mo_text_id")
	// 	);
	// },

    showPageByNumber : function (pageNumber) {

        // Set the current page
        this.pages.goToPage(pageNumber, this.viewerModel.get("syntheticLayout"), this.spineItemModel.get("firstPageIsOffset"));
        this.showPage(pageNumber);
    },

    showPageByCFI : function (CFI) {

        // Errors have to be handled from the library
        var $rangeTargetElements;
        var $standardTargetElement;
        var targetElement;
        try {

            // Check if it's a CFI range type
            if (new RegExp(/.+,.+,.+/).test(CFI)) {
                $rangeTargetElements = this.cfi.getRangeTargetElements(CFI, $(this.getEpubContentDocument()).parent()[0]);
                targetElement = $rangeTargetElements[0];
            }
            else {
                $standardTargetElement = this.cfi.getTargetElement(CFI, $(this.getEpubContentDocument()).parent()[0]);
                targetElement = $standardTargetElement[0];
            }
        }
        catch (error) {
            // Maybe check error type
            throw error;
        }

        // Find the page number for the first element that the CFI refers to
        var page = this.reflowableElementsInfo.getElemPageNumber(
            targetElement, 
            this.offsetDirection(), 
            this.reflowablePaginator.page_width, 
            this.reflowablePaginator.gap_width,
            this.getEpubContentDocument());

        if (page > 0) {
            this.pages.goToPage(page, this.viewerModel.get("syntheticLayout"), this.spineItemModel.get("firstPageIsOffset")); 
        }
        else {
            throw new Error("The page specified by the CFI could not be found");
        }
    },

    // The package document needs to get passed into the view, or the API needs to change. This is not critical at the moment.
    //
    // // Description: Generates a CFI for an element is that is currently visible on the page. This CFI and a last-page payload
    // //   is then saved for the current EPUB.
    // savePosition : function () {

    //     var $visibleTextNode;
    //     var CFI;

    //     // Get first visible element with a text node 
    //     $visibleTextNode = this.reflowableElementsInfo.findVisibleTextNode(
    //         this.getEpubContentDocument(), 
    //         this.viewerModel.get("two_up"),
    //         // REFACTORING CANDIDATE: These two properties should be stored another way. This should be 
    //         //   temporary.
    //         this.reflowablePaginator.gap_width,
    //         this.reflowablePaginator.page_width
    //         );

    //     CFI = this.annotations.findExistingLastPageMarker($visibleTextNode);
    //     if (!CFI) {

    //     	CFI = this.annotations.generateCharacterOffsetCFI(
    //     		this.reflowableElementsInfo.findVisibleCharacterOffset($visibleTextNode, this.getEpubContentDocument()),
				// $visibleTextNode[0],
				// this.spineItemModel.get("idref"),
				// this.epubController.getPackageDocumentDOM()
	   //      	);
    //     }
    //     this.annotations.saveAnnotation(CFI, this.spineItemModel.get("spine_index"));
    // },

    showView : function () {
        
        this.$el.show();
        this.updatePageNumber();
    },

    hideView : function () {
        
        this.$el.hide();
    },

	// Description: Find an element with this specified id and show the page that contains the element.
	goToHashFragment : function(hashFragmentId) {

		// this method is triggered in response to 
		var fragment = hashFragmentId;
		if(fragment) {
			var el = $("#" + fragment, this.getEpubContentDocument())[0];

			if(!el) {
				// couldn't find the el. just give up
                return;
			}

			// we get more precise results if we look at the first children
			while (el.children.length > 0) {
				el = el.children[0];
			}

			var page = this.reflowableElementsInfo.getElemPageNumber(
				el, 
				this.offsetDirection(), 
				this.reflowablePaginator.page_width, 
				this.reflowablePaginator.gap_width,
				this.getEpubContentDocument());

            if (page > 0) {
                //console.log(fragment + " is on page " + page);
                this.pages.goToPage(page, this.viewerModel.get("syntheticLayout"), this.spineItemModel.get("firstPageIsOffset"));	
			}
            else {
                // Throw an exception here 
            }
		}
		// else false alarm no work to do
	},

    onFirstPage : function () {

        // Rationale: Need to check for both single and synthetic page spread
        var oneOfCurrentPagesIsFirstPage = this.pages.get("current_page")[0] === 1 ? true :
                                           this.pages.get("current_page")[1] === 1 ? true : false;

        if (oneOfCurrentPagesIsFirstPage) {
            return true;
        }
        else {
            return false;
        }
    },

    onLastPage : function () {

        // Rationale: Need to check for both single and synthetic page spread
        var oneOfCurrentPagesIsLastPage = this.pages.get("current_page")[0] === this.pages.get("num_pages") ? true :
                                          this.pages.get("current_page")[1] === this.pages.get("num_pages") ? true : false;

        if (oneOfCurrentPagesIsLastPage) {
            return true;
        }
        else {
            return false;
        }
    },

    showPage : function(page) {

        var offset = this.calcPageOffset(page).toString() + "px";
        $(this.getEpubContentDocument()).css(this.offsetDirection(), "-" + offset);
        this.showContent();
        
        // if (this.viewerModel.get("twoUp") == false || 
        //     (this.viewerModel.get("twoUp") && page % 2 === 1)) {
        //         // when we change the page, we have to tell MO to update its position
        //         // this.mediaOverlayController.reflowPageChanged();
        // }
    },

    setFontSize : function (fontSize) {
        this.viewerModel.set({ fontSize : fontSize });
        if (this.annotations) {
            this.annotations.redraw();
        }
    },

    setMargin : function (margin) {
        this.viewerModel.set({ currentMargin : margin });
        if (this.annotations) {
            this.annotations.redraw();
        }
    },

    setTheme : function (theme) {
        this.viewerModel.set({ currentTheme : theme });
        if (this.annotations) {
            this.annotations.redraw();
        }
    },

    setSyntheticLayout : function (isSynthetic) {
    
        // Rationale: Only toggle the layout if a change is required        
        if (isSynthetic !== this.viewerModel.get("syntheticLayout")) {
            this.viewerModel.set({ syntheticLayout : isSynthetic });
            this.pages.toggleTwoUp(isSynthetic, this.spineItemModel.get("firstPageIsOffset"));
        }
        if (this.annotations) {
            this.annotations.redraw();
        }
    },

    nextPage : function () {

        var isSynthetic = this.viewerModel.get("syntheticLayout");
        this.pages.nextPage(isSynthetic);
    },

    previousPage : function () {

        var isSynthetic = this.viewerModel.get("syntheticLayout");
        this.pages.prevPage(isSynthetic);
    },

	// ------------------------------------------------------------------------------------ //
	//  PRIVATE GETTERS FOR VIEW                                                            //
	// ------------------------------------------------------------------------------------ //    

	getFlowingWrapper : function () {
		return this.el;
	},

	getReadiumFlowingContent : function () {
		return $(this.el).children()[0];
	},

    // REFACTORING CANDIDATE: That's a lot of chaining right there. Too much. 
	getEpubContentDocument : function () {
		return $($($(this.el).children()[0]).contents()[0]).children()[0];
	},

	getSpineDivider : function () {
		return $(".reflowing-spine-divider")[0];
	},

	// ------------------------------------------------------------------------------------ //
	// PRIVATE EVENT HANDLERS                               								//
	// ------------------------------------------------------------------------------------ //

	keydownHandler : function (e) {

        if (e.which == 39) {
            this.trigger("keydown-right");
        }
                        
        if (e.which == 37) {
            this.trigger("keydown-left");
        }
    },

	pageChangeHandler: function() {

        var that = this;
		this.hideContent();
		setTimeout(function () {

			that.showPage(that.pages.get("current_page")[0]);
			// that.savePosition();
			that.showContent();

		}, 150);
	},

	windowSizeChangeHandler: function() {

		this.paginateContentDocument();
		
		// Make sure we return to the correct position in the epub (This also requires clearing the hash fragment) on resize.
		// this.goToHashFragment(this.epubController.get("hash_fragment"));
	},
    
	rePaginationHandler: function() {

		this.paginateContentDocument();
	},

	themeChangeHandler : function () {

		this.reflowableLayout.injectTheme(
			this.viewerModel.get("currentTheme"), 
			this.getEpubContentDocument(), 
			this.getFlowingWrapper());
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS AND UTILITY METHODS                                               //
	// ------------------------------------------------------------------------------------ //

    // Rationale: The "paginator" model uses the scrollWidth of the paginated xhtml content document in order
    //   to calculate it's number of pages (given the current screen size etc.). It appears that 
    //   the scroll width property is either buggy, unreliable, or changes by small amounts between the time the content
    //   document is paginated and when it is used. Regardless of the cause, the scroll width is understated, which causes
    //   the number of pages to be understated. As a result, the last page of a content document is often not shown when 
    //   a user moves to the last page of the content document. This method recalculates the number of pages for the current
    //   scroll width of the content document. 
    updatePageNumber : function () {
        
        var recalculatedNumberOfPages;
        var epubContentDocument = this.getEpubContentDocument();
        var isSyntheticLayout = this.viewerModel.get("syntheticLayout");
        var currScrollWidth = epubContentDocument.scrollWidth;
        var lastScrollWidth = this.reflowablePaginator.get("lastScrollWidth");

        if (lastScrollWidth !== currScrollWidth) {
            recalculatedNumberOfPages = this.reflowablePaginator.calcNumPages(epubContentDocument, isSyntheticLayout);
            this.pages.set("num_pages", recalculatedNumberOfPages);
            this.reflowablePaginator.set("lastScrollWidth", currScrollWidth);
        }
    },

	// Rationale: This method delegates the pagination of a content document to the reflowable layout model
	paginateContentDocument : function () {

		var pageInfo = this.reflowablePaginator.paginateContentDocument(
			this.getSpineDivider(),
			this.viewerModel.get("syntheticLayout"),
			this.offsetDirection(),
			this.getEpubContentDocument(),
			this.getReadiumFlowingContent(),
			this.getFlowingWrapper(),
			this.spineItemModel.get("firstPageIsOffset"),
			this.pages.get("current_page"),
			this.spineItemModel.get("pageProgressionDirection"),
			this.viewerModel.get("currentMargin"),
			this.viewerModel.get("fontSize")
			);

		this.pages.set("num_pages", pageInfo[0]);
		this.showPage(pageInfo[1]);
	},

	initializeContentDocument : function () {

		var elementId = this.reflowableLayout.initializeContentDocument(
			this.getEpubContentDocument(), 
			this.epubCFIs, 
			this.spineItemModel.get("spine_index"), 
			this.getReadiumFlowingContent(), 
			this.linkClickHandler, 
			this, 
			this.viewerModel.get("currentTheme"), 
			this.getFlowingWrapper(), 
			this.getReadiumFlowingContent(), 
			this.keydownHandler,
            this.bindings
			);

		return elementId;
	},

	// Rationale: For the purpose of looking up EPUB resources in the package document manifest, Readium expects that 
	//   all relative links be specified as relative to the package document URI (or absolute references). However, it is 
	//   valid XHTML for a link to another resource in the EPUB to be specfied relative to the current document's
	//   path, rather than to the package document. As such, URIs passed to Readium must be either absolute references or 
	//   relative to the package document. This method resolves URIs to conform to this condition. 
	resolveRelativeURI : function (rel_uri) {
		var relativeURI = new URI(rel_uri);

		// Get URI for resource currently loaded in the view's iframe
		var iframeDocURI = new URI($(this.getReadiumFlowingContent()).attr("src"));
		return relativeURI.resolve(iframeDocURI).toString();
	},

	hideContent : function() {
		$(this.getFlowingWrapper()).css("opacity", "0");
	},

	showContent : function() {
		$(this.getFlowingWrapper()).css("opacity", "1");
	},

	calcPageOffset : function(page_num) {
		return (page_num - 1) * (this.reflowablePaginator.page_width + this.reflowablePaginator.gap_width);
	},

	offsetDirection : function () {

		// if this book does right to left pagination we need to set the
		// offset on the right
		if (this.spineItemModel.get("pageProgressionDirection") === "rtl") {
			return "right";
		}
		else {
			return "left";
		}
	}
}); 

    var reflowableView = new EpubReflowable.ReflowablePaginationView({  
        spineItem : spineObject, 
        viewerSettings : viewerSettingsObject, 
        contentDocumentCFIs : CFIAnnotations, 
        bindings : bindings
    });

    // Description: The public interface
    return {

        render : function (goToLastPage, hashFragmentId) { return reflowableView.render.call(reflowableView, goToLastPage, hashFragmentId); },
        nextPage : function () { return reflowableView.nextPage.call(reflowableView); },
        previousPage : function () { return reflowableView.previousPage.call(reflowableView); },
        showPageByHashFragment : function (hashFragmentId) { return reflowableView.goToHashFragment.call(reflowableView, hashFragmentId); },
        showPageByNumber : function (pageNumber) { return reflowableView.showPageByNumber.call(reflowableView, pageNumber); },
        showPageByCFI : function (CFI) { reflowableView.showPageByCFI.call(reflowableView, CFI); }, 
        onFirstPage : function () { return reflowableView.onFirstPage.call(reflowableView); },
        onLastPage : function () { return reflowableView.onLastPage.call(reflowableView); },
        showPagesView : function () { return reflowableView.showView.call(reflowableView); },
        hidePagesView : function () { return reflowableView.hideView.call(reflowableView); },
        numberOfPages : function () { return reflowableView.pages.get("num_pages"); },
        currentPage : function () { return reflowableView.pages.get("current_page"); },
        setFontSize : function (fontSize) { return reflowableView.setFontSize.call(reflowableView, fontSize); },
        setMargin : function (margin) { return reflowableView.setMargin.call(reflowableView, margin); },
        setTheme : function (theme) { return reflowableView.setTheme.call(reflowableView, theme); },
        setSyntheticLayout : function (isSynthetic) { return reflowableView.setSyntheticLayout.call(reflowableView, isSynthetic); },
        on : function (eventName, callback, callbackContext) { return reflowableView.on.call(reflowableView, eventName, callback, callbackContext); },
        off : function (eventName, callback) { return reflowableView.off.call(reflowableView, eventName, callback); },
        // addSelectionHighlight : function (id) { return reflowableView.annotations.addSelectionHighlight.call(reflowableView.annotations, id); },
        // addSelectionBookmark : function (id) { return reflowableView.annotations.addSelectionBookmark.call(reflowableView.annotations, id); },
        // addHighlight : function (CFI, id) { return reflowableView.annotations.addHighlight.call(reflowableView.annotations, CFI, id); },
        // addBookmark : function (CFI, id) { return reflowableView.annotations.addBookmark.call(reflowableView.annotations, CFI, id); }
    };
};

    var EpubFixedModule = function (spineObjects, viewerSettingsObject) {
    
    var EpubFixed = {};

    // Rationale: The order of these matters
    // Description: This model is responsible determining page numbers to display for fixed layout EPUBs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer. The logic for this is reasonably complex, as there a number of different factors that must be
//   taken into account in various cases. These include: The page progression direction, 
//   the reading order of pages, the number of pages displayed on the screen, and author preferences 
//   for the location of pages (left/right/center). 

EpubFixed.PageNumberDisplayLogic = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize : function () {},

    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //   pageProgressionDirection ("rtl" or "ltr): The page progression direction
    //	)
	getPageNumbers : function (gotoPageNumber, twoUp, pageProgressionDirection) {

		if (twoUp) {
			
			if (pageProgressionDirection === "rtl") {

				if (this.pageIsLeft(gotoPageNumber)) {

					if (this.pageIsRight(gotoPageNumber - 1)) {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {
						return [gotoPageNumber];
					}
				}
				else if (this.pageIsRight(gotoPageNumber)) {

					if (this.pageIsLeft(gotoPageNumber + 1)) {
						return [gotoPageNumber, gotoPageNumber + 1];	
					}
					else {
						return [gotoPageNumber];
					}
				}
				// A center page
				else {
					return [gotoPageNumber];
				}
			}
			// Left-to-right page progression
			else {

				if (this.pageIsLeft(gotoPageNumber)) {

					if (this.pageIsRight(gotoPageNumber + 1)) {
						return [gotoPageNumber, gotoPageNumber + 1];
					}
					else {
						return [gotoPageNumber];
					}
				}
				else if (this.pageIsRight(gotoPageNumber)) {

					if (this.pageIsLeft(gotoPageNumber - 1)) {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {
						return [gotoPageNumber];
					}
				}
				// A center page
				else {
					return [gotoPageNumber];
				}
			}
		}
		else {	
			return [gotoPageNumber];
		}
	},

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	getPreviousPageNumbers : function (currentPages, twoUp, pageProgressionDirection) {

		var curr_pg = currentPages;
		var lastPage = curr_pg[0] - 1;

		// Single page navigation
		if (!twoUp){
			return [lastPage];
		}
		else if (pageProgressionDirection === "rtl") {

			// If the first page is a left page in rtl progression, only one page 
			// can be displayed, even in two-up mode
			if (this.pageIsLeft(lastPage) && 
				this.pageIsRight(lastPage - 1)) {

				return [lastPage - 1, lastPage];
			}
			else {

				return [lastPage];
			}
		}
		// Left-to-right progresion
		else {

			if (this.pageIsRight(lastPage) &&
				this.pageIsLeft(lastPage - 1)) {

				return [lastPage - 1, lastPage];
			}
			else {

				return [lastPage];
			}
		}
	},

	// Description: Get the pages to display when moving in reading order
    // Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	getNextPageNumbers : function (currentPages, twoUp, pageProgressionDirection) {

		var curr_pg = currentPages;
		var firstPage = curr_pg[curr_pg.length - 1] + 1;

		if (!twoUp) {
			return [firstPage];
		}
		else if (pageProgressionDirection === "rtl") {

			// If the first page is a left page in rtl progression, only one page 
			// can be displayed, even in two-up mode
			if (this.pageIsRight(firstPage) &&
				this.pageIsLeft(firstPage + 1)) {

				return [firstPage, firstPage + 1];
			}
			else {

				return [firstPage];
			}
		}
		else {

			if (this.pageIsLeft(firstPage) && 
				this.pageIsRight(firstPage + 1)) {

				return [firstPage, firstPage + 1];
			}
			else {

				return [firstPage];
			}
		}
	},

	// Description: This method determines which page numbers to display when switching
	//   between a single page and side-by-side page views and vice versa.
	// Arguments (
	//   currentPages (array of integers): An array of page numbers that are currently displayed	
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   pageProgressionDirection ("rtl" or "ltr): The page progression direction
	//	)
	// Notes: Authors can specify a fixed layout page as a "center" page, which prevents more than one page
	//   being displayed. This case is not handled yet.
	getPageNumbersForTwoUp : function (currentPages, twoUp, pageProgressionDirection) {

		var displayed = currentPages;
		var twoPagesDisplayed = displayed.length === 2 ? true : false;
		var newPages = [];

		// Two pages are currently displayed; find the single page number to display
		if (twoPagesDisplayed) {

			// Rationale: I think this check is a bit of a hack, for the case in which a set of pages is [0, 1]. Pages are
			//   1-indexed, so the "0" in the 0 index position of the array is not valid.
			if (displayed[0] === 0) {
				
				newPages[0] = 1;
			} 
			else {
				
				newPages[0] = displayed[0];
			}
		}
		// A single fixed layout page is displayed
		else {

			// page progression is right-to-left
			if (pageProgressionDirection === "rtl") {

				// and the previous one is right, then display both, otherwise, just display one
				if (this.pageIsLeft(displayed[0])) {
					
					if (this.pageIsRight(displayed[0] - 1)) {

						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// if the next page is left, display both, otherwise, just display one
				else if (this.pageIsRight(displayed[0])) {
					
					if (this.pageIsLeft(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
			// page progression is left-to-right
			else {

				// If next page is a right page, display both, otherwise just display this one
				if (this.pageIsLeft(displayed[0])) {
					
					if (this.pageIsRight(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				else if (this.pageIsRight(displayed[0])) {
					
					if (this.pageIsLeft(displayed[0] - 1)) {
						
						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
		}

		return newPages;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: The `displayedPageIs...` methods determine if a fixed layout page is right, left or center.
	pageIsRight : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "right") {
			return true;
		}
		else {
			return false;
		}
	},

	pageIsLeft : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "left") {
			return true;
		}
		else {
			return false;
		}
	},

	pageIsCenter : function (pageNumber) {

		var pageIndex = pageNumber - 1;
		var spineObject = this.get("spineObjects")[pageIndex];
		if (spineObject !== undefined && spineObject.pageSpread === "center") {
			return true;
		}
		else {
			return false;
		}
	}
});
    EpubFixed.FixedPageViews = Backbone.Model.extend({

    defaults : function () {

        return {
            "fixedPages" : [],
            "currentPages" : [1],
        }
    },

    // -------------------------------------------- PUBLIC INTERFACE ---------------------------------

    initialize : function (attributes, options) {

        this.fixedPagination = new EpubFixed.PageNumberDisplayLogic({ spineObjects : this.get("spineObjects") });

        // Rationale: Get the page progression direction off the first spine object. This assumes that ppd is the 
        //   same for all FXL spine objects in the epub - which it should be. 
        this.set("pageProgressionDirection", this.get("spineObjects")[0].pageProgressionDirection);
    },

    loadFixedPages : function (bindingElement, viewerSettings) {

        // Reset the default for a synthetic layout
        if (viewerSettings.syntheticLayout) {
            this.set("currentPages", [1, 2]);
        }

        this.loadPageViews(viewerSettings);
        this.renderAll(bindingElement);
    },

    nextPage : function (twoUp) {

        var newPageNums;
        if (this.onLastPage()) {
            return;
        }

        newPageNums = this.fixedPagination.getNextPageNumbers(this.get("currentPages"), twoUp, this.get("pageProgressionDirection"));
        this.resetCurrentPages(newPageNums);
    },

    previousPage : function (twoUp) {

        var newPageNums;
        if (this.onFirstPage()) {
            return;
        }

        newPageNums = this.fixedPagination.getPreviousPageNumbers(this.get("currentPages"), twoUp, this.get("pageProgressionDirection"));
        this.resetCurrentPages(newPageNums);
    },

    onFirstPage : function () {

        if (this.get("currentPages")[0] <= 1) {
            return true;
        }

        return false;
    },

    onLastPage : function () {

        if (this.get("currentPages")[0]) {
            if (this.get("currentPages")[0] >= this.numberOfPages()) {
                return true;
            }
        }

        if (this.get("currentPages")[1]) {
            if (this.get("currentPages")[1] >= this.numberOfPages()) {
                return true;
            }
        }

        return false;
    },

    showPageNumber : function (pageNumber, syntheticLayout) {

        var pageIndexToShow;
        var fixedPageView;
        var pageNumsToShow = this.fixedPagination.getPageNumbers(pageNumber, syntheticLayout, this.get("pageProgressionDirection"));
        this.resetCurrentPages(pageNumsToShow);
    },

    setSyntheticLayout : function (isSynthetic) {

        var newPageNumbers;
        if (isSynthetic) {

            _.each(this.get("fixedPages"), function (fixedPageInfo) {
                fixedPageInfo.fixedPageView.setSyntheticPageSpreadStyle();
            });
        }
        else {

            _.each(this.get("fixedPages"), function (fixedPageInfo) {
                fixedPageInfo.fixedPageView.setSinglePageSpreadStyle();
            });
        }

        // Rationale: This method toggles the page numbers
        newPageNumbers = this.fixedPagination.getPageNumbersForTwoUp(this.get("currentPages"), undefined, this.get("pageProgressionDirection"));
        this.resetCurrentPages(newPageNumbers);
    },

    // -------------------------------------------- PRIVATE HELPERS ---------------------------------

    hidePageViews : function () {

        _.each(this.get("fixedPages"), function (fixedPageInfo) {
            fixedPageInfo.fixedPageView.hidePage();
        });      
    },

    numberOfPages : function () {

        return this.get("fixedPages").length;
    },

    loadPageViews : function (viewerSettings) {

        var that = this;
        _.each(this.get("spineObjects"), function (spineObject) {

            var fixedPageView;
            var fixedPageViewInfo;
            if (spineObject.fixedLayoutType === "image") {
                fixedPageView = that.initializeImagePage(spineObject.pageSpread, spineObject.contentDocumentURI, viewerSettings);
            }
            // SVG and all others
            else {
                fixedPageView = that.initializeFixedPage(spineObject.pageSpread, spineObject.contentDocumentURI, viewerSettings);
            }

            // Create info object
            fixedPageViewInfo = {
                fixedPageView : fixedPageView,
                pageType : spineObject.fixedLayoutType,
                isRendered : false,
                spineIndex : spineObject.spineIndex
            };

            that.get("fixedPages").push(fixedPageViewInfo);
        });
    },

    renderAll : function (bindingElement) {

        var that = this;
        var numFixedPages = this.get("fixedPages").length;
        
        _.each(this.get("fixedPages"), function (fixedPageViewInfo) {

            fixedPageViewInfo.fixedPageView.on("contentDocumentLoaded", function (viewElement) { 

                fixedPageViewInfo.isRendered = true;
                fixedPageViewInfo.fixedPageView.hidePage();

                numFixedPages = numFixedPages - 1; 
                if (numFixedPages === 0) {
                    that.trigger("epubLoaded");
                }
            });
            
            that.addPageViewToDom(bindingElement, fixedPageViewInfo.fixedPageView.render(false, undefined));
        });

        setTimeout(function () { 
            
            if (numFixedPages != 0) {
                // throw an exception
            }

        }, 1000);
    },

    addPageViewToDom : function (bindingElement, pageViewElement) {

        $(bindingElement).append(pageViewElement);
    },

    resetCurrentPages : function (currentPages) {

        this.set("currentPages", currentPages);
        this.hidePageViews();

        if (currentPages[0] !== undefined && currentPages[0] !== null) {
            this.getPageViewInfo(currentPages[0]).fixedPageView.showPage();
        }

        if (currentPages[1] !== undefined && currentPages[1] !== null) {
            this.getPageViewInfo(currentPages[1]).fixedPageView.showPage();
        }
    },

    getPageViewInfo : function (pageNumber) {

        var pageIndex = pageNumber - 1;
        return this.get("fixedPages")[pageIndex];
    },

    initializeImagePage : function (pageSpread, imageSrc, viewerSettings) {

        return new EpubFixed.ImagePageView({
                        pageSpread : pageSpread,
                        imageSrc : imageSrc,
                        viewerSettings : viewerSettings
                    });
    },

    initializeFixedPage : function (pageSpread, iframeSrc, viewerSettings) {

        return new EpubFixed.FixedPageView({
                        pageSpread : pageSpread,
                        iframeSrc : iframeSrc,
                        viewerSettings : viewerSettings
                    });
    }
});
    EpubFixed.FixedSizing = Backbone.Model.extend({

    metaSize : {
        width : undefined,
        height : undefined
    },

    initialize : function (attributes) {},

    // ------------------ PUBLIC INTERFACE ---------------------------------

    updateMetaSize : function () {

        var $img;
        var contentDocument = this.get("contentDocument");

        // first try to read viewport size
        var content = $('meta[name=viewport]', contentDocument).attr("content");

        // if not found try viewbox (used for SVG)
        if (!content) {
            content = $('meta[name=viewbox]', contentDocument).attr("content");
        }

        if (content) {
            var size = this.parseSize(content);
            if (size) {
                this.metaSize.width = size.width;
                this.metaSize.height = size.height;
            }
        }
        else { //try to get direct image size

            if ($(contentDocument).is("IMG")) {
                $img = $(contentDocument);
            }
            else {
                $img = $(contentDocument).find('img');
            }
            var width = $img.width();
            var height = $img.height();

            if (width > 0) {
                this.metaSize.width = width;
                this.metaSize.height = height;
            }
        }
    },

    fitToScreen : function (containerWidth, containerHeight) {

        var bookSize = this.metaSize;
        if (bookSize.width == 0) {
            return;
        }

        var horScale = containerWidth / bookSize.width;
        var verScale = containerHeight / bookSize.height;

        var scale = Math.min(horScale, verScale);

        var css = this.generateTransformCSS(scale);
        css["width"] = bookSize.width;
        css["height"] = bookSize.height;

        return css;
    },

    // --------------------------- PRIVATE HELPERS -------------------------------------

    parseSize : function (content) {

        var pairs = content.replace(/\s/g, '').split(",");
        var dict = {};
        var width;
        var height;

        for (var i = 0; i < pairs.length; i++) {

            var nameVal = pairs[i].split("=");
            if (nameVal.length === 2) {
                dict[nameVal[0]] = nameVal[1];
            }
        }

        width = Number.NaN;
        height = Number.NaN;

        if (dict["width"]) {
            width = parseInt(dict["width"]);
        }

        if (dict["height"]) {
            height = parseInt(dict["height"]);
        }

        if (!isNaN(width) && !isNaN(height)) {
            return { 
                width : width, 
                height : height
            };
        }

        return undefined;
    },

    // Have to modernizer this
    generateTransformCSS : function (scale) {

        var transformString = "scale(" + scale + ")";

        //modernizer library can be used to get browser independent transform attributes names (implemented in readium-web fixed_layout_book_zoomer.js)
        var css = {};
        css["-webkit-transform"] = transformString;
        return css;
    }
});
    EpubFixed.FixedLayoutStyle = Backbone.Model.extend({

    initialize : function () {},

    getSinglePageSpreadCSS : function () {

        // @include box-shadow(0 0 5px 5px rgba(80,80,80,0.5));
        return {
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%",
            "-webkit-transform-origin" : "top left",
            "left" : "25%"
        };
    },

    getPageSpreadLeftCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "right" : "50%",
            "left" : "", // Have to clear the left if it was set for this page on a single page spread
            "-webkit-transform-origin" : "top right",
            "background-color" : "#FFF"
        };
    },

    getPageSpreadRightCSS : function () {

        return { 
            "position" : "absolute",
            "overflow" : "hidden",
            "height" : "100%",
            "width" : "50%", 
            "left" : "50%",
            "-webkit-transform-origin" : "top left",
            "background-color" : "#FFF" 
        };
    },

    getPageSpreadCenterCSS : function () {

        return {
            "position" : "absolute",
            "overflow" : "hidden", 
            "height" : "100%",
            "width" : "100%",
            "left" : "50%",
            "z-index" : "11",
            "background-color" : "#FFF" 
        };
    }
});
    EpubFixed.FixedPageView = Backbone.View.extend({

    el : "<div class='fixed-page-wrapper'> \
            <iframe scrolling='no' \
                    frameborder='0' \
                    marginwidth='0' \
                    marginheight='0' \
                    style='height:100%;width:100%;' \
                    class='fixed-content'> \
            </iframe> \
          </div>",

    initialize : function (options) {

        this.sizing;
        this.styles = new EpubFixed.FixedLayoutStyle();
        this.pageSpread = options.pageSpread;
        this.iframeSrc = options.iframeSrc;
        if (options.viewerSettings.syntheticLayout) {
            this.setSyntheticPageSpreadStyle();       
        }
        else {
            this.setSinglePageSpreadStyle();
        }
    },

    render : function () {

        var that = this;
        this.get$iframe().attr("src", this.iframeSrc);
        this.get$iframe().on("load", function () {

            that.sizing = new EpubFixed.FixedSizing({ contentDocument : that.get$iframe()[0].contentDocument });
            // this.injectLinkHandler(e.srcElement);
            // that.applyKeydownHandler($(view.iframe()));
            that.setPageSize();
            that.trigger("contentDocumentLoaded");
        });
        
        return this.el;
    },

    get$iframe : function () {
        return $("iframe", this.$el);
    },

    hidePage : function () {
        this.$el.hide();
    },

    showPage : function () {
        this.$el.show();
    },

    setSinglePageSpreadStyle : function () {

        var transformCss;
        this.$el.css(this.styles.getSinglePageSpreadCSS());
        this.setPageSize();
    },

    setSyntheticPageSpreadStyle : function () {

        var pageSpread = this.pageSpread;
        var transformCss;
        if (pageSpread === "left") {
            this.$el.css(this.styles.getPageSpreadLeftCSS());
        }
        else if (pageSpread === "right") {
            this.$el.css(this.styles.getPageSpreadRightCSS());
        }
        else if (pageSpread === "center") {
            this.$el.css(this.styles.getPageSpreadCenterCSS());
        }
        this.setPageSize();
    },

    setPageSize : function () {

        var $readerElement = this.$el.parent().parent();
        if (this.sizing !== undefined) {

            var transformCss;
            this.sizing.updateMetaSize();
            transformCss = this.sizing.fitToScreen($readerElement.width(), $readerElement.height());
            this.$el.css(transformCss);
        }
    }
});
    EpubFixed.ImagePageView = Backbone.View.extend({

    el : "<div class='fixed-page-wrapper' style='height:100%;'> \
            <img src='#'' alt=''/> \
          </div>",

    initialize : function (options) {

        this.sizing;
        this.styles = new EpubFixed.FixedLayoutStyle();
        this.pageSpread = options.pageSpread;
        this.imageSrc = options.imageSrc;
        if (options.viewerSettings.syntheticLayout) {
            this.setSyntheticPageSpreadStyle();       
        }
        else {
            this.setSinglePageSpreadStyle();
        }
    },

    render : function () {

        var that = this;
        $("img", this.$el).attr("src", this.imageSrc);
        this.$("img").on("load", function() { 

            that.sizing = new EpubFixed.FixedSizing({ contentDocument : $("img", this.el)[0] });
            // that.injectLinkHandler();
            // that.applyKeydownHandler($(view.iframe()));
            // that.mediaOverlayController.pagesLoaded();
            that.setPageSize();
            that.trigger("contentDocumentLoaded");
        });

        return this.el;
    },

    hidePage : function () {
        this.$el.hide();
    },

    showPage : function () {
        this.$el.show();
    },

    setSinglePageSpreadStyle : function () {

        var transformCss;
        this.$el.css(this.styles.getSinglePageSpreadCSS());
        this.setPageSize();
    },

    setSyntheticPageSpreadStyle : function () {

        var pageSpread = this.pageSpread;
        var transformCss;
        if (pageSpread === "left") {
            this.$el.css(this.styles.getPageSpreadLeftCSS());
        }
        else if (pageSpread === "right") {
            this.$el.css(this.styles.getPageSpreadRightCSS());
        }
        else if (pageSpread === "center") {
            this.$el.css(this.styles.getPageSpreadCenterCSS());
        }
        this.setPageSize();
    },

    setPageSize : function () {

        var $readerElement = this.$el.parent().parent();
        if (this.sizing !== undefined) {

            var transformCss;
            this.sizing.updateMetaSize();
            transformCss = this.sizing.fitToScreen($readerElement.width(), $readerElement.height());
            this.$el.css(transformCss);
        }
    }
});
    EpubFixed.FixedPaginationView = Backbone.View.extend({

	el : "<div class='fixed-pages-view' style='position:relative;'> \
            <div class='fixed-spine-divider'></div> \
          </div>",

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize : function (options) {

		var that = this;
		this.fixedPageViews = new EpubFixed.FixedPageViews({ spineObjects : options.spineObjects });
		this.viewerSettings = options.viewerSettings;

		// Rationale: Propagate the loaded event after all the content documents are loaded
        this.fixedPageViews.on("epubLoaded", function () {
            that.trigger("contentDocumentLoaded");
            that.$el.css("opacity", "1");
        }, this);

		// this.mediaOverlayController = this.model.get("media_overlay_controller");
        // this.mediaOverlayController.setPages(this.pages);
        // this.mediaOverlayController.setView(this);

        // this.mediaOverlayController.on("change:mo_text_id", this.highlightText, this);
        // this.mediaOverlayController.on("change:active_mo", this.indicateMoIsPlaying, this);
	},

	render : function (goToLastPage, hashFragmentId) {

		var that = this;
		this.fixedPageViews.loadFixedPages(this.$el[0], this.viewerSettings);
		return this.el;
	},

    // REFACTORING CANDIDATE: Might want these methods to be the goLeft and goRight methods
	nextPage : function () {

		this.fixedPageViews.nextPage(this.viewerSettings.syntheticLayout);
	},

	previousPage : function () {

		this.fixedPageViews.previousPage(this.viewerSettings.syntheticLayout);
	},

    setSyntheticLayout : function (isSynthetic) {

        if (isSynthetic && this.viewerSettings.syntheticLayout === false) {
            this.viewerSettings.syntheticLayout = true;
            this.fixedPageViews.setSyntheticLayout(true);
        }
        else if (!isSynthetic && this.viewerSettings.syntheticLayout === true) {
            this.viewerSettings.syntheticLayout = false;
            this.fixedPageViews.setSyntheticLayout(false);
        }
    },

    showPageNumber : function (pageNumber) {

        this.fixedPageViews.showPageNumber(pageNumber, this.viewerSettings.syntheticLayout);
    },

    showPagesView : function () {

        var currentPageNumber = this.fixedPageViews.get("currentPages")[0];
        this.$el.show();
        this.fixedPageViews.showPageNumber(currentPageNumber, this.viewerSettings.syntheticLayout);
    },

    hidePagesView : function () {

        this.$el.hide();
        this.fixedPageViews.hidePageViews();
    },
    
 //    // override
	// indicateMoIsPlaying: function () {
	// 	var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderFixedMoPlaying(
	// 		this.pages.get("current_page"),
	// 		this.mediaOverlayController.get("active_mo"),
	// 		this
 //        );
	// },
    
 //    // override
	// highlightText: function () {
	// 	var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
	// 	moHelper.renderFixedLayoutMoFragHighlight(
	// 		this.pages.get("current_page"),
	// 		this.mediaOverlayController.get("mo_text_id"),
	// 		this
 //        );
	// },
    
 //    // override
 //    // Description: return the set of all elements for this spine item that have an @id attribute.
 //    // Used by MO.
 //    getAllPageElementsWithId: function() {
 //        return $('body').find("[id]");
 //    },
    
    
	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	destruct : function () {

        // this.mediaOverlayController.off("change:mo_text_id", this.highlightText);
        // this.mediaOverlayController.off("change:active_mo", this.indicateMoIsPlaying);
		// this.resetEl();
	},

	// setFontSize: function() {
	// 	var size = this.model.get("font_size") / 10;
	// 	$('#readium-content-container').css("font-size", size + "em");
	// 	this.showCurrentPages();
	// },

	applyKeydownHandler : function ($pageViewContainer) {

		var that = this;
		$pageViewContainer.contents().keydown(function (e) {

			if (e.which == 39) {
				that.pages.goRight(); // Have to get ppd and two up
			}
							
			if (e.which == 37) {
				that.pages.goLeft(); // Have to get ppd and two up
			}
		});
	},

	injectLinkHandler : function (iframe) {

    	var that = this;
    	$('a', iframe.contentDocument).click(function(e) {
    		that.linkClickHandler(e)
    	});
    }
}); 

    var fixedView = new EpubFixed.FixedPaginationView({  
        spineObjects : spineObjects, 
        viewerSettings : viewerSettingsObject
    });

    // Description: The public interface
    return {

        render : function (goToLastPage, hashFragmentId) { return fixedView.render.call(fixedView, goToLastPage, hashFragmentId); },
        nextPage : function () { return fixedView.nextPage.call(fixedView); },
        previousPage : function () { return fixedView.previousPage.call(fixedView); },
        showPageByHashFragment : function (hashFragmentId) { return; },
        showPageByNumber : function (pageNumber) { return fixedView.showPageNumber.call(fixedView, pageNumber); },
        showPageByCFI : function (CFI) { return; }, 
        onFirstPage : function () { return fixedView.fixedPageViews.onFirstPage.call(fixedView.fixedPageViews); },
        onLastPage : function () { return fixedView.fixedPageViews.onLastPage.call(fixedView.fixedPageViews); },
        showPagesView : function () { return fixedView.showPagesView.call(fixedView); },
        hidePagesView : function () { return fixedView.hidePagesView.call(fixedView); },
        numberOfPages : function () { return fixedView.fixedPageViews.get("fixedPages").length; },
        currentPage : function () { return fixedView.fixedPageViews.get("currentPages"); },
        setFontSize : function (fontSize) { return; },
        setMargin : function (margin) { return; },
        setTheme : function (theme) { return; },
        setSyntheticLayout : function (isSynthetic) { return fixedView.setSyntheticLayout.call(fixedView, isSynthetic); },
        on : function (eventName, callback, callbackContext) { return fixedView.on.call(fixedView, eventName, callback, callbackContext); },
        off : function (eventName, callback) { return fixedView.off.call(fixedView, eventName, callback); }//,
        // addSelectionHighlight : function (id) { return reflowableView.annotations.addSelectionHighlight.call(reflowableView.annotations, id); },
        // addSelectionBookmark : function (id) { return reflowableView.annotations.addSelectionBookmark.call(reflowableView.annotations, id); },
        // addHighlight : function (CFI, id) { return reflowableView.annotations.addHighlight.call(reflowableView.annotations, CFI, id); },
        // addBookmark : function (CFI, id) { return reflowableView.annotations.addBookmark.call(reflowableView.annotations, CFI, id); }
    };
};

    var EpubParserModule = function(packageDocumentURI, packageDocumentXML) {
    
    var EpubParser = {};
    // `PackageDocumentParser` is used to parse the xml of an epub package
// document and build a javascript object. The constructor accepts an
// instance of `URI` that is used to resolve paths during the process
EpubParser.PackageDocumentParser = Backbone.Model.extend({

    initialize : function (attributes, options) {

        this.packageDocumentURI = new URI(this.get("packageDocumentURI"));
        var xml = this.get("packageDocumentXML");
        if (typeof(xml) === "string" ) {
            var parser = new window.DOMParser;
            xmlDom = parser.parseFromString(xml, 'text/xml');
            this.set({ xmlDom : xmlDom });
        }
        else {
            throw new Error("XML string representation of package document is required");
        }
    },

    // Parse an XML package document into a javascript object
    parse : function() {

        var json, manifest, cover, xmlDom;
        var xmlDom = this.get("xmlDom");

        json = {};
        json.metadata = this.getJsonMetadata(xmlDom);
        json.bindings = this.getJsonBindings(xmlDom);
        json.spine = this.getJsonSpine(xmlDom);
        json.manifest = this.getJsonManifest(xmlDom);

        // parse the page-progression-direction if it is present
        json.paginate_backwards = this.paginateBackwards(xmlDom);

        // try to find a cover image
        cover = this.getCoverHref(xmlDom);
        if (cover) {
            json.metadata.cover_href = cover;
        }       
        if (json.metadata.layout === "pre-paginated") {
            json.metadata.fixed_layout = true;
        }
        
        // THIS SHOULD BE LEFT IN (BUT COMMENTED OUT), AS MO SUPPORT IS TEMPORARILY DISABLED
        // create a map of all the media overlay objects
        // json.mo_map = this.resolveMediaOverlays(json.manifest);

        // parse the spine into a proper collection
        json.spine = this.parseSpineProperties(json.spine);

        // return the parse result
        return json;
    },

    getJsonSpine : function () {

        var $spineElements;
        var jsonSpine = [];
        var xmlDom = this.get("xmlDom");

        $spineElements = $("spine", xmlDom).children();
        $.each($spineElements, function (spineElementIndex, currSpineElement) {

            var $currSpineElement = $(currSpineElement);
            var spineItem = {

                idref : $currSpineElement.attr("idref") ? $currSpineElement.attr("idref") : "",
                linear : $currSpineElement.attr("linear") ? $currSpineElement.attr("linear") : "",
                properties : $currSpineElement.attr("properties") ? $currSpineElement.attr("properties") : ""
            };

            jsonSpine.push(spineItem);
        });

        return jsonSpine;
    },

    getJsonMetadata : function () {

        var xmlDom = this.get("xmlDom");
        var $metadata = $("metadata", xmlDom);
        var jsonMetadata = {};

        jsonMetadata.active_class = $("meta[property='media:active-class']", $metadata).text();
        jsonMetadata.author = $("creator", $metadata).text();
        jsonMetadata.description = $("description", $metadata).text();
        jsonMetadata.epub_version = $("package", xmlDom).attr("version") ? $("package", xmlDom).attr("version") : "";
        jsonMetadata.id = $("identifier", $metadata).text();
        jsonMetadata.language = $("language", $metadata).text();
        jsonMetadata.layout = $("meta[property='rendition:layout']", $metadata).text();
        jsonMetadata.modified_date = $("meta[property='dcterms:modified']", $metadata).text();
        jsonMetadata.ncx = $("spine", xmlDom).attr("toc") ? $("spine", xmlDom).attr("toc") : "";
        jsonMetadata.orientation = $("meta[property='rendition:orientation']", $metadata).text();
        jsonMetadata.page_prog_dir = $("spine", xmlDom).attr("page-progression-direction") ? $("spine", xmlDom).attr("page-progression-direction") : "";
        jsonMetadata.pubdate = $("date", $metadata).text();
        jsonMetadata.publisher = $("publisher", $metadata).text();
        jsonMetadata.rights = $("rights").text();
        jsonMetadata.spread = $("meta[property='rendition:spread']", $metadata).text();
        jsonMetadata.title = $("title", $metadata).text();

        return jsonMetadata;
    },

    getJsonManifest : function () {

        var that = this;
        var xmlDom = this.get("xmlDom");
        var $manifestItems = $("manifest", xmlDom).children(); 
        var jsonManifest = [];

        $.each($manifestItems, function (manifestElementIndex, currManifestElement) {

            var $currManifestElement = $(currManifestElement);
            var currManifestElementHref = $currManifestElement.attr("href") ? $currManifestElement.attr("href") : "";
            var manifestItem = {

                contentDocumentURI : that.resolveURI(currManifestElementHref),
                href : currManifestElementHref,
                id : $currManifestElement.attr("id") ? $currManifestElement.attr("id") : "", 
                media_overlay : $currManifestElement.attr("media-overlay") ? $currManifestElement.attr("media-overlay") : "",
                media_type : $currManifestElement.attr("media-type") ? $currManifestElement.attr("media-type") : "",
                properties : $currManifestElement.attr("properties") ? $currManifestElement.attr("properties") : ""
            };

            jsonManifest.push(manifestItem);
        });

        return jsonManifest;
    },

    getJsonBindings : function () {

        var xmlDom = this.get("xmlDom");
        var $bindings = $("bindings", xmlDom).children();
        var jsonBindings = [];

        $.each($bindings, function (bindingElementIndex, currBindingElement) {

            var $currBindingElement = $(currBindingElement);
            var binding = {

                handler : $currBindingElement.attr("handler") ? $currBindingElement.attr("handler") : "" ,
                media_type : $currBindingElement.attr("media-type") ? $currBindingElement.attr("media-type") : "" 
            };

            jsonBindings.push(binding);
        });

        return jsonBindings;
    },

    getCoverHref : function() {

        var dom = this.get("xmlDom");
        var manifest; var $imageNode;
        manifest = dom.getElementsByTagName('manifest')[0];

        // epub3 spec for a cover image is like this:
        /*<item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />*/
        $imageNode = $('item[properties~="cover-image"]', manifest);
        if($imageNode.length === 1 && $imageNode.attr("href") ) {
            return $imageNode.attr("href");
        }

        // some epub2's cover image is like this:
        /*<meta name="cover" content="cover-image-item-id" />*/
        var metaNode = $('meta[name="cover"]', dom);
        var contentAttr = metaNode.attr("content");
        if(metaNode.length === 1 && contentAttr) {
            $imageNode = $('item[id="'+contentAttr+'"]', manifest);
            if($imageNode.length === 1 && $imageNode.attr("href")) {
                return $imageNode.attr("href");
            }
        }

        // that didn't seem to work so, it think epub2 just uses item with id=cover
        $imageNode = $('#cover', manifest);
        if($imageNode.length === 1 && $imageNode.attr("href")) {
            return $imageNode.attr("href");
        }

        // seems like there isn't one, thats ok...
        return null;
    },

    parseSpineProperties : function(spine) {
        
        var parseProperiesString = function(str) {
            var properties = {};
            var allPropStrs = str.split(" "); // split it on white space
            for(var i = 0; i < allPropStrs.length; i++) {
                // brute force!!!
                //rendition:orientation landscape | portrait | auto
                //rendition:spread none | landscape | portrait | both | auto

                //rendition:page-spread-center 
                //page-spread | left | right
                //rendition:layout reflowable | pre-paginated
                if(allPropStrs[i] === "rendition:page-spread-center") properties.page_spread = "center";
                if(allPropStrs[i] === "page-spread-left") properties.page_spread = "left";
                if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
                if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
                if(allPropStrs[i] === "rendition:layout-reflowable") properties.fixed_flow = false;
                if(allPropStrs[i] === "rendition:layout-pre-paginated") properties.fixed_flow = true;
            }
            return properties;
            
        }

        for (var i = 0; i < spine.length; i++) {
            var props = parseProperiesString(spine[i].properties);
            // add all the properties to the spine item
            _.extend(spine[i], props);
        }
        return spine;
    },

    // resolve the url of smils on any manifest items that have a MO
    // attribute

    // NOTE: Removed media overlay support for the module refactoring

    // resolveMediaOverlays : function(manifest) {
    //     var that = this;
    //     var momap = {};
        
    //     // create a bunch of media overlay objects
    //     manifest.forEach( function(item) {
    //         if(item.get("media_type") === "application/smil+xml") {
    //             var url = that.resolveUri(item.get("href"));
    //             var moObject = new EpubParser.MediaOverlay();
    //             moObject.setUrl(url);
    //             moObject.fetch(); 
    //             momap[item.id] = moObject;
    //         }
    //     });
    //     return momap;
    // },

    // parse the EPUB3 `page-progression-direction` attribute
    paginateBackwards : function() {

        var xmlDom = this.get("xmlDom");
        return $('spine', xmlDom).attr('page-progression-direction') === "rtl";
    },

    resolveURI : function (epubResourceURI) {

        // Make absolute to the package document path
        var epubResourceRelURI = new URI(epubResourceURI);
        var epubResourceAbsURI = epubResourceRelURI.absoluteTo(this.packageDocumentURI);
        return epubResourceAbsURI.toString();
    }
});

    var packageDocParser = new EpubParser.PackageDocumentParser({ 
        packageDocumentURI : packageDocumentURI,
        packageDocumentXML : packageDocumentXML 
    });

    // Description: The public interface
    return {

        parse : function () { return packageDocParser.parse.call(packageDocParser); }
    };
};

    var EpubModule = function(packageDocumentObject, packageDocumentXML) {
    
    var Epub = {};

    // Rationale: The order of these matters
    Epub.ManifestItem = Backbone.Model.extend({

	isSvg : function () {
		
		return this.get("media_type") === "image/svg+xml";
	},

	isImage : function () {
		
		var media_type = this.get("media_type");
		if (media_type && media_type.indexOf("image/") > -1) {
			// we want to treat svg as a special case, so they
			// are not images
			return media_type !== "image/svg+xml";
		}
		return false;
	}	
});
    Epub.Manifest = Backbone.Collection.extend({

    model : Epub.ManifestItem
});
    Epub.Metadata = Backbone.Model.extend({});
    // Description: This is a delegate that provides information about the appropriate page-spread property for fixed layout spine items
Epub.PageSpreadProperty = Backbone.Model.extend({

    initialize : function () {

        // "Constants" for page spread class
        this.CENTER_PAGE = "center_page";
        this.LEFT_PAGE = "left_page";
        this.RIGHT_PAGE = "right_page";
    },

    inferiBooksPageSpread : function (spineIndex, numSpineItems) {

        var pageNum = spineIndex + 1;

        // Rationale: For ibooks, odd pages go on the right. This means
        // the first page will always be on the right
        // without a left counterpart, so center it
        if (pageNum === 1) {
            
            return this.CENTER_PAGE;
        }
        // Rationale: If the last spine item in the book would be on the left, then
        //   it would have no left counterpart, so center it
        else if (pageNum % 2 === 0 && pageNum === numSpineItems) { 
            
            return this.CENTER_PAGE;
        }
        // Rationale: Otherwise first page goes on the right, and then alternate
        // left - right - left - right etc
        else {

            if (pageNum % 2 === 1) {
                return this.RIGHT_PAGE;
            }
            else {
                return this.LEFT_PAGE;
            }
        }
    },

    getPageSpreadFromProperties : function (pageSpreadProperty) {

        if (pageSpreadProperty === "left") {

            return this.LEFT_PAGE;
        }
        else if (pageSpreadProperty === "right") {

            return this.RIGHT_PAGE;
        }
        else if (pageSpreadProperty === "center") {

            return this.CENTER_PAGE;
        }
        else {

            return "";
        }
    },

    // NOTE: This method still cannot infer the page spread value when center pages are sporadically specified
    // REFACTORING CANDIDATE: Could still use some refactoring to enhance the clarity of the algorithm
    
    // Rationale: If the page spread property is not set, we must iterate back through the EPUB's spine items to find 
    //   the last spine item with a page-spread value set. We can use that value, whether there are an even or odd
    //   number of pages between this spine item and the "last" one, and the page progression direction of the EPUB
    //   to determine the appropriate page spread value for this spine item. 
    inferUnassignedPageSpread : function (spineIndex, spine, pageProgDirection) {

        var lastSpecifiedPageSpread;
        var numPagesBetween;

        if (spine.at(spineIndex).get("page_spread") === "left" ||
            spine.at(spineIndex).get("page_spread") === "right" ||
            spine.at(spineIndex).get("page_spread") === "center") {

            return this.getPageSpreadFromProperties(spine.at(spineIndex).get("page_spread"));
        }
        // If this is the first spine item, assign left or right based on page progression direction
        else if (spineIndex === 0) {

            return pageProgDirection === "rtl" ? this.RIGHT_PAGE : this.LEFT_PAGE;
        }
        else {

            // Find last spine item with page-spread value and use it to determine the appropriate value for 
            //   this spine item. This loop iterates, in reverse order, from the current spine index to the
            //   spine item that had a specified page spread specified. 
            for (var currSpineIndex = spineIndex - 1; currSpineIndex >= 0; currSpineIndex--) {

                // REFACTORING CANDIDATE: This would be clearer if the currSpineIndex === 0 case was 
                //   handled seperately. 
                if (currSpineIndex === 0 || spine.at(currSpineIndex).get("page_spread")) {

                    lastSpecifiedPageSpread = this.lastSpecifiedPageSpread(
                        spine.at(currSpineIndex).get("page_spread"), 
                        pageProgDirection
                        );
                    numPagesBetween = spineIndex - currSpineIndex;

                    // Even number of pages between current and last spine item
                    if (numPagesBetween % 2 === 0) {

                        return lastSpecifiedPageSpread === "left" ? this.LEFT_PAGE : 
                            lastSpecifiedPageSpread === "right" ? this.RIGHT_PAGE :
                            pageProgDirection === "rtl" ? this.LEFT_PAGE : this.RIGHT_PAGE;
                    }
                    // Odd number of pages between current and last spine item with a specified page-spread value
                    else {

                        return lastSpecifiedPageSpread === "left" ? this.RIGHT_PAGE :
                            lastSpecifiedPageSpread === "right" ? this.LEFT_PAGE :
                            pageProgDirection === "rtl" ? this.RIGHT_PAGE : this.LEFT_PAGE;
                    }
                }
            }
        }
    },

    lastSpecifiedPageSpread : function (pageSpreadValue, pageProgDirection) {

        // Handles the case where currSpineIndex === 0 and a page-spread value has not been specified
        if (pageSpreadValue && pageSpreadValue !== "") {
            return pageSpreadValue;
        }
        else {
            return pageProgDirection === "rtl" ? "right" : "left";
        }
    }
});
    Epub.SpineItem = Epub.ManifestItem.extend({

    defaults : {
        "pageSpreadClass" : ""
    },

    initialize : function () {

        // if (this.isFixedLayout()) {
        //     this.on("change:content", this.parseMetaTags, this);
        //     this.loadContent();
        // }
    },

    // REFACTORING CANDIDATE: The meta tags thing has to be worked out
    // toJSON : function () {

        // var json = {};
        // json.width = this.get("meta_width") || 0;
        // json.height = this.get("meta_height") || 0;
        // json.uri = this.resolveUri(this.get('href'));
        // json.page_class = this.getPageSpreadClass();
        // return json;
    // },

    // REFACTORING CANDIDATE: This needs to change

    isFixedLayout : function () {

        // if it an svg or image then it is fixed layout
        if (this.isSvg() || this.isImage()) {
            return true;
        }

        // if there is a fixed_flow property, then it takes precedence
        if (typeof this.get("fixed_flow") !== 'undefined') {
            return this.get("fixed_flow");
        }

        // nothing special about this spine item, fall back to the books settings
        return false;
    },

    // Description: Determines if the first page of the content document should be offset in a synthetic layout
    firstPageOffset : function () {

        // Get book properties
        var notFixedLayout = !this.isFixedLayout();
        var pageProgDirIsRTL = this.get("page_prog_dir") === "rtl" ? true : false;
        var pageSpreadLeft = this.get("page_spread") === "left" ? true : false;
        var pageSpreadRight = this.get("page_spread") === "right" ? true : false;

        // Default to no page spread specified if they are both set on the spine item
        if (pageSpreadRight && pageSpreadLeft) {
            pageSpreadRight = false;
            pageSpreadLeft = false;
        }

        if (notFixedLayout) {

            if (pageProgDirIsRTL) {

                if (pageSpreadLeft) {
                    return true;
                }
            }
            else {

                if (pageSpreadRight) {
                    return true;
                }
            }
        }

        return false;
    },

    // NOTE: Media overlays have been disabled for the time being, which is why these methods are commented out. 

    // hasMediaOverlay : function() {
    //     return !!this.get("media_overlay") && !!this.getMediaOverlay();
    // },
    
    // getMediaOverlay : function() {
    //     return this.collection.getMediaOverlay(this.get("media_overlay"));
    // }
});
    Epub.Spine = Backbone.Collection.extend({

    model: Epub.SpineItem,
});
    // Description: This model provides an interface for navigating an EPUB's package document
Epub.PackageDocument = Backbone.Model.extend({

    initialize : function (attributes, options) {

        var packageDocument = this.get("packageDocumentObject");
        this.manifest = new Epub.Manifest(packageDocument.manifest);
        this.spine = new Epub.Spine(packageDocument.spine);
        this.metadata = new Epub.Metadata(packageDocument.metadata);
        this.bindings = new Epub.Spine(packageDocument.bindings);
        this.pageSpreadProperty = new Epub.PageSpreadProperty();

        // If this book is fixed layout, assign the page spread class
        if (this.isFixedLayout()) {
            this.assignPageSpreadClass();
        }
    },

    getSpineInfo : function () {

        var that = this;
        var spineInfo = [];
        this.spine.each(function (spineItem) {

            spineInfo.push(that.generateSpineInfo(spineItem));
        });

        return {
            spine : spineInfo, 
            bindings : this.bindings.toJSON()
        };
    },

    isFixedLayout : function () {

        if (this.metadata.get("fixed_layout")) {
            return true; 
        }
        else {
            return false;
        }
    },

    getManifestItemById : function (id) {

        var foundManifestItem = this.manifest.find(
            function (manifestItem) { 
                if (manifestItem.get("id") === id) {
                    return manifestItem;
                }
            });

        if (foundManifestItem) {
            return foundManifestItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    getManifestItemByIdref : function (idref) {

        var foundManifestItem = this.getManifestItemById(idref);
        if (foundManifestItem) {
            return foundManifestItem;
        }
        else {
            return undefined;
        }
    },

    getSpineItemByIdref : function (idref) {

        var foundSpineItem = this.getSpineModelByIdref(idref);
        if (foundSpineItem) {
            return foundSpineItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    getSpineItem : function (spineIndex) {

        var spineItem = this.spine.at(spineIndex);
        if (spineItem) {
            return spineItem.toJSON();
        }
        else {
            return undefined;
        }
    },

    spineLength : function () {
        return this.spine.length;
    },

    // Description: gets the next position in the spine for which the
    // spineItem does not have `linear='no'`. The start
    // param is the non-inclusive position to begin the search
    // from. If start is not supplied, the search will begin at
    // postion 0. If no linear position can be found, this 
    // function returns undefined
    getNextLinearSpinePosition : function (currSpineIndex) {

        var spine = this.spine;
        if (currSpineIndex === undefined || currSpineIndex < 0) {
            currSpineIndex = 0;

            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        while (currSpineIndex < this.spineLength() - 1) {
            currSpineIndex += 1;
            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        // No next linear spine position.
        return undefined; 
    },

    // Description: gets the previous position in the spine for which the
    // spineItem does not have `linear='no'`. The start
    // param is the non-inclusive position to begin the search
    // from. If start is not supplied, the search will begin at
    // the end of the spine. If no linear position can be found, 
    // this function returns undefined
    getPrevLinearSpinePosition : function(currSpineIndex) {

        var spine = this.spine;
        if (currSpineIndex === undefined || currSpineIndex > this.spineLength() - 1) {
            currSpineIndex = this.spineLength() - 1;

            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        while (currSpineIndex > 0) {
            currSpineIndex -= 1;
            if (spine.at(currSpineIndex).get("linear") !== "no") {
                return currSpineIndex;
            }
        }

        // No previous linear spine position.
        return undefined;
    },

    hasNextSection: function(currSpineIndex) {

        if (currSpineIndex >= 0 &&
            currSpineIndex <= this.spineLength() - 1) {
            
            return this.getNextLinearSpinePosition(currSpineIndex) > -1;
        }
        else {
            return false;
        }
    },

    hasPrevSection: function(currSpineIndex) {

        if (currSpineIndex >= 0 &&
            currSpineIndex <= this.spineLength() - 1) {

            return this.getPrevLinearSpinePosition(currSpineIndex) > -1;    
        }
        else {
            return false;
        }
    },

    pageProgressionDirection : function () {

        if (this.metadata.get("page_prog_dir") === "rtl") {
            return "rtl";
        }
        else if (this.metadata.get("page_prog_dir") === "default") {
            return "default";
        }
        else {
            return "ltr";
        }
    },

    getSpineIndexByHref : function (manifestHref) {

        var spineItem = this.getSpineModelFromHref(manifestHref);
        return this.getSpineIndex(spineItem);
    },

    getBindingByHandler : function (handler) {

        var binding = this.bindings.find(
            function (binding) {

                if (binding.get("handler") === handler) {
                    return binding;
                }
            });

        if (binding) {
            return binding.toJSON();
        }
        else {
            return undefined;
        }
    },

    generateSpineInfo : function (spineItem) {

        var isFixedLayout = false;
        var fixedLayoutType = undefined;
        var manifestItem = this.getManifestModelByIdref(spineItem.get("idref"));

        // Get fixed layout properties
        if (spineItem.isFixedLayout() || this.isFixedLayout()) {
            isFixedLayout = true;
            
            if (manifestItem.isSvg()) {
                fixedLayoutType = "svg";
            }
            else if (manifestItem.isImage()) {
                fixedLayoutType = "image";
            }
            else {
                fixedLayoutType = "xhtml";
            }
        }

        return {
            contentDocumentURI : this.getManifestItemByIdref(spineItem.get("idref")).contentDocumentURI,
            title : this.metadata.get("title"),
            firstPageIsOffset : false, // This needs to be determined
            pageProgressionDirection : this.pageProgressionDirection(),
            spineIndex : this.getSpineIndex(spineItem),
            pageSpread : spineItem.get("page_spread"),
            isFixedLayout : isFixedLayout, 
            fixedLayoutType : fixedLayoutType,
            mediaType : manifestItem.get("media_type")
        };
    },

    getPackageDocumentDOM : function () {

        var parser = new window.DOMParser;
        var packageDocumentDom = parser.parseFromString(this.get("packageDocument"), "text/xml");
        return packageDocumentDom;
    },

    getToc: function() {

        var item = this.getTocItem();
        if (item){
            var href = item.get("href");
            return href;
        }
        return null;
    },


    // ----------------------- PRIVATE HELPERS -------------------------------- //

    // Refactoring candidate: This search will always iterate through entire manifest; this should be modified to 
    //   return when the manifest item is found.
    getSpineModelFromHref : function (manifestHref) {

        var that = this;
        var resourceURI = new URI(manifestHref);
        var resourceName = resourceURI.filename();
        var foundSpineModel; 

        this.manifest.each(function (manifestItem) {

            var manifestItemURI = new URI(manifestItem.get("href"));
            var manifestItemName = manifestItemURI.filename();

            // Rationale: Return a spine model based on the manifest item id, which is the idref of the spine item
            if (manifestItemName === resourceName) {
                foundSpineModel = that.getSpineModelByIdref(manifestItem.get("id"));
            }
        });

        return foundSpineModel;
    },

    getSpineModelByIdref : function (idref) {

        var foundSpineItem = this.spine.find(
            function (spineItem) { 
                if (spineItem.get("idref") === idref) {
                    return spineItem;
                }
            });

        return foundSpineItem;
    },

    getManifestModelByIdref : function (idref) {

        var foundManifestItem = this.manifest.find(
            function (manifestItem) { 
                if (manifestItem.get("id") === idref) {
                    return manifestItem;
                }
            });

        return foundManifestItem;
    },

    getSpineIndex : function (spineItem) {

        return this.spine.indexOf(spineItem);
    },

    // Description: When rendering fixed layout pages we need to determine whether the page
    //   should be on the left or the right in two up mode, options are:
    //     left_page:      render on the left side
    //     right_page:     render on the right side
    //     center_page:    always center the page horizontally
    //   This property must be assigned when the package document is initialized
    // NOTE: Look into how spine items with the linear="no" property affect this algorithm 
    assignPageSpreadClass : function () {

        var that = this;
        var pageSpreadClass;
        var numSpineItems;

        // If the epub is apple fixed layout
        if (this.metadata.get("apple_fixed")) {

            numSpineItems = this.spine.length;
            this.spine.each(function (spineItem, spineIndex) {

                pageSpreadClass = that.pageSpreadProperty.inferiBooksPageSpread(spineIndex, numSpineItems);
                spineItem.set({ pageSpreadClass : pageSpreadClass });
            });
        }
        else {
            // For each spine item
            this.spine.each(function (spineItem, spineIndex) {

                if (spineItem.get("page_spread")) {

                    pageSpreadClass = that.pageSpreadProperty.getPageSpreadFromProperties(spineItem.get("page_spread"));
                    spineItem.set({ pageSpreadClass : pageSpreadClass });
                }
                else {

                    pageSpreadClass = that.pageSpreadProperty.inferUnassignedPageSpread(spineIndex, that.spine, that.pageProgressionDirection());
                    spineItem.set({ pageSpreadClass : pageSpreadClass });
                }
            });
        }
    },

    getTocItem : function() {

        var manifest = this.manifest;
        var metadata = this.metadata;
        var spine_id = this.metadata.get("ncx");

        var item = manifest.find(function(item){

            if (item.get("properties").indexOf("nav") !== -1) {
                return true;
            }
            else {
                return false;
            }
        });

        if( item ) {
            return item;
        }

        if( spine_id && spine_id.length > 0 ) {
            return manifest.find(function(item) {
                return item.get("id") === spine_id;
            });
        }

        return null;
    }

    // NOTE: Media overlays are temporarily disabled
    // getMediaOverlayItem : function(idref) {
    //     // just look up the object in the mo_map
    //     var map = this.get("mo_map");
    //     return map && map[idref];
    // },
});


    var packageDoc = new Epub.PackageDocument({ 
        packageDocumentObject : packageDocumentObject,
        packageDocument : packageDocumentXML
    });

    // Description: The public interface
    return {

        getSpineInfo : function () { return packageDoc.getSpineInfo.call(packageDoc); },
        isFixedLayout : function () { return packageDoc.isFixedLayout.call(packageDoc); },
        getManifestItemById : function (id) { return packageDoc.getManifestItemById.call(packageDoc, id); },
        getManifestItemByIdref : function (idref) { return packageDoc.getManifestItemByIdref.call(packageDoc, idref); }, 
        getSpineItemByIdref : function (idref) { return packageDoc.getSpineItemByIdref.call(packageDoc, idref); },
        getSpineItemByIndex : function (spineIndex) { return packageDoc.getSpineItem.call(packageDoc, spineIndex); }, 
        spineLength : function () { return packageDoc.spineLength.call(packageDoc); }, 
        getNextLinearSpinePosition : function (currSpineIndex) { return packageDoc.getNextLinearSpinePosition.call(packageDoc, currSpineIndex); },
        getPrevLinearSpinePosition : function (currSpineIndex) { return packageDoc.getPrevLinearSpinePosition.call(packageDoc, currSpineIndex); }, 
        hasNextSection : function (currSpineIndex) { return packageDoc.hasNextSection.call(packageDoc, currSpineIndex); }, 
        hasPrevSection : function (currSpineIndex) { return packageDoc.hasPrevSection.call(packageDoc, currSpineIndex); }, 
        pageProgressionDirection : function () { return packageDoc.pageProgressionDirection.call(packageDoc); },
        getSpineIndexByHref : function (manifestHref) { return packageDoc.getSpineIndexByHref.call(packageDoc, manifestHref); },
        getPackageDocumentDOM : function () { return packageDoc.getPackageDocumentDOM.call(packageDoc); },
        getToc : function () { return packageDoc.getToc.call(packageDoc); }
    };
};

    var EpubReaderModule = function(readerBoundElement, epubSpineInfo, viewerSettings, packageDocumentDOM) {
    
    var EpubReader = {};

    // Rationale: The order of these matters
    EpubReader.LoadStrategy = Backbone.Model.extend({

    defaults : {
        "numFixedPagesPerView" : 100
    },

    initialize : function (attributes, options) {},

    // Description: This method chooses the appropriate page view to load for individual 
    //   spine items, and sections of the spine. 
    loadSpineItems : function (viewerSettings, annotations, bindings) {

        var spineIndex;
        var currSpineItem;
        var currFixedSpineItems = [];
        var nextSpineItem;
        var pagesViews = [];
        var currPageView;
        var nextSpineItem;
        for (spineIndex = 0; spineIndex <= this.get("spineInfo").length - 1; spineIndex++) {

            currSpineItem = this.get("spineInfo")[spineIndex];

            // A fixed layout spine item
            if (currSpineItem.isFixedLayout) {

                currFixedSpineItems.push(currSpineItem);

                // Check how many fixed pages have been added for the next view
                if (currFixedSpineItems.length === this.get("numFixedPagesPerView")) {

                    currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                    pagesViews.push(currPageView);
                    currFixedSpineItems = [];
                    continue;
                }

                nextSpineItem = this.get("spineInfo")[spineIndex + 1];
                if (nextSpineItem) {

                    if (!nextSpineItem.isFixedLayout) {

                        currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                        pagesViews.push(currPageView);
                        currFixedSpineItems = [];
                    }
                }
                else {
                    currPageView = this.loadFixedPagesView(currFixedSpineItems, viewerSettings);
                    pagesViews.push(currPageView);
                    currFixedSpineItems = [];
                }
            }
            // A scrolling spine item 
            else if (currSpineItem.shouldScroll) {

                // Load the scrolling pages view
            }
            // A reflowable spine item
            else {
                currPageView = this.loadReflowablePagesView(currSpineItem, viewerSettings, annotations, bindings);
                pagesViews.push(currPageView);
            }
        }

        return pagesViews;
    },

    loadReflowablePagesView : function (spineItem, viewerSettings, annotations, bindings) {

        var view = new EpubReflowableModule(
            spineItem,
            viewerSettings, 
            annotations, 
            bindings
            );

        var pagesViewInfo = {
            pagesView : view, 
            spineIndexes : [spineItem.spineIndex],
            isRendered : false,
            type : "reflowable"
        };

        return pagesViewInfo;
    },

    loadFixedPagesView : function (spineItemList, viewerSettings) {

        var view = new EpubFixedModule(
            spineItemList,
            viewerSettings
        );

        var spineIndexes = [];
        _.each(spineItemList, function (spineItem) {
            spineIndexes.push(spineItem.spineIndex)
        });

        var pagesViewInfo = {
            pagesView : view, 
            spineIndexes : spineIndexes,
            isRendered : false,
            type : "fixed"
        };

        return pagesViewInfo;
    }
});
    EpubReader.EpubReader = Backbone.Model.extend({

    defaults : function () { 
        return {
            "loadedPagesViews" : [],
            "currentPagesViewIndex" : 0,
            "pagesViewEventList" : []
        };
    },

    initialize : function (attributes, options) {

        var spineInfo = this.get("spineInfo");
        this.set("spine", spineInfo.spine);
        this.set("bindings", spineInfo.bindings);
        this.set("annotations", spineInfo.annotations);

        this.loadStrategy = new EpubReader.LoadStrategy({ spineInfo : this.get("spine")});
        this.cfi = new EpubCFIModule();
    },

    // ------------------------------------------------------------------------------------ //  
    //  "PUBLIC" INTERFACE                                                                  //
    // ------------------------------------------------------------------------------------ //  

    numberOfLoadedPagesViews : function () {

        return this.get("loadedPagesViews").length;
    },

    hasNextPagesView : function () {

        return this.get("currentPagesViewIndex") < this.numberOfLoadedPagesViews() - 1 ? true : false;
    },

    hasPreviousPagesView : function () {

        return this.get("currentPagesViewIndex") > 0 ? true : false;
    },

    getCurrentPagesView : function () {

        return this.get("loadedPagesViews")[this.get("currentPagesViewIndex")].pagesView;
    },

    renderPagesView : function (pagesViewIndex, renderLast, hashFragmentId) {

        var pagesView;
        if (pagesViewIndex >= 0 && pagesViewIndex < this.numberOfLoadedPagesViews()) {

            this.hideRenderedViews();
            this.set({"currentPagesViewIndex" : pagesViewIndex});
            pagesViewInfo = this.getCurrentPagesViewInfo();
            pagesView = pagesViewInfo.pagesView;

            if (pagesViewInfo.isRendered) {
                pagesView.showPagesView();
                this.applyPreferences(pagesView);
                if (renderLast) {
                    pagesView.showPageByNumber(pagesView.numberOfPages());
                }
            }
            else {
                
                viewElement = pagesViewInfo.pagesView.render(renderLast, hashFragmentId);
                $(this.get("parentElement")).append(viewElement);
                this.applyPreferences(pagesViewInfo.pagesView);
                pagesViewInfo.isRendered = true;
            }
        }
    },

    renderNextPagesView : function () {

        var nextPagesViewIndex;
        if (this.hasNextPagesView()) {
            nextPagesViewIndex = this.get("currentPagesViewIndex") + 1;
            this.renderPagesView(nextPagesViewIndex, false, undefined);
        }
    },

    renderPreviousPagesView : function () {

        var previousPagesViewIndex;
        if (this.hasPreviousPagesView()) {
            previousPagesViewIndex = this.get("currentPagesViewIndex") - 1;
            this.renderPagesView(previousPagesViewIndex, true, undefined);
        }
    },

    // This is an asychronous method
    getRenderedPagesView : function (spineIndex, callback, callbackContext) {

        // Get pages view info
        var that = this;
        var viewElement;
        var pagesViewInfo = this.getPagesViewInfo(spineIndex);

        // Check if it is rendered
        if (!pagesViewInfo.isRendered) {

            // invoke callback when the content document loads
            pagesViewInfo.pagesView.on("contentDocumentLoaded", function (pagesView) {
                callback.call(callbackContext, pagesViewInfo.pagesView);
            });

            // This logic is duplicated and should be abstracted
            viewElement = pagesViewInfo.pagesView.render(false, undefined);
            $(this.get("parentElement")).append(viewElement);
            this.applyPreferences(pagesViewInfo.pagesView);
            pagesViewInfo.isRendered = true;
        }
        else {
            callback.call(callbackContext, pagesViewInfo.pagesView);
        }
    },

    attachEventHandler : function (eventName, callback, callbackContext) {

        // Rationale: Maintain a list of the callbacks, which need to be attached when pages views are loaded
        this.get("pagesViewEventList").push({
            eventName : eventName,
            callback : callback,
            callbackContext : callbackContext
        });

        // Attach the event handler to each current pages view
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {
            pagesViewInfo.pagesView.on(eventName, callback, callbackContext);
        }, this);
    },

    removeEventHandler : function (eventName) {

        var that = this;
        // Find index of events
        var indexOfEventsToRemove = [];
        _.each(this.get("pagesViewEventList"), function (pagesViewEvent, index) {

            if (pagesViewEvent.eventName === eventName) {
                indexOfEventsToRemove.push(index);
            }
        });

        // Remove them in reverse order, so each index is still valid
        indexOfEventsToRemove.reverse();
        _.each(indexOfEventsToRemove, function (indexToRemove) {
            that.get("pagesViewEventList").splice(indexToRemove, 1);
        });

        // Remove event handlers on views
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {
            pagesViewInfo.pagesView.off(eventName);
        }, this);
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    eagerRenderStrategy : function () {

        var that = this;
        var numPagesViewsToLoad = this.get("loadedPagesViews").length;
        
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {

            pagesViewInfo.pagesView.on("contentDocumentLoaded", function (viewElement) { 

                pagesViewInfo.isRendered = true;
                pagesViewInfo.pagesView.hidePagesView();

                numPagesViewsToLoad = numPagesViewsToLoad - 1; 
                if (numPagesViewsToLoad === 0) {
                    that.trigger("epubLoaded");
                }
            });
            
            // This will cause the pages view to try to retrieve its resources
            $(that.get("parentElement")).append(pagesViewInfo.pagesView.render(false, undefined));
        });

        setTimeout(function () { 
            
            if (numPagesViewsToLoad != 0) {
                // throw an exception
            }

        }, 1000);
    },

    // Description: This method chooses the appropriate page view to load for individual 
    //   spine items, and sections of the spine. 
    loadSpineItems : function () {

        var pagesViews = this.loadStrategy.loadSpineItems(this.get("viewerSettings"), this.get("annotations"), this.get("bindings"));
        this.set("loadedPagesViews", pagesViews);
        // Attach list of event handlers
        // _.each(this.get("pagesViewEventList"), function (eventInfo) {
        //     view.on(eventInfo.eventName, eventInfo.callback, eventInfo.callbackContext);
        // });
        this.eagerRenderStrategy();
    },

    getCurrentPagesViewInfo : function () {

        return this.get("loadedPagesViews")[this.get("currentPagesViewIndex")];
    },

    hideRenderedViews : function () {

        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {

            if (pagesViewInfo.isRendered) {
                pagesViewInfo.pagesView.hidePagesView();
            }
        });
    },

    // REFACTORING CANDIDATE: The each method is causing numPages and currentPage to be hoisted into the global
    //   namespace, I believe. Bad bad. Check this.
    calculatePageNumberInfo : function () {

        var that = this;
        var numPages = 0;
        var currentPage;
        _.each(this.get("loadedPagesViews"), function (pagesViewInfo) {

            // Calculate current page number
            if (that.getCurrentPagesView() === pagesViewInfo.pagesView) {
                currentPage = numPages + pagesViewInfo.pagesView.currentPage()[0];
            }

            // Sum up number of pages
            if (pagesViewInfo.isRendered) {
                numPages += pagesViewInfo.pagesView.numberOfPages();
            }
        });

        return { 
            numPages : numPages,
            currentPage : currentPage
        };
    },

    // REFACTORING CANDIDATE: This method should be replaced when the epub reader api is changed to have an 
    //   instantiated epub module passed to it. 
    findSpineIndex : function (contentDocumentHref) {

        var contentDocHref = contentDocumentHref;
        var foundSpineItem;

        foundSpineItem = _.find(this.get("spine"), function (spineItem, index) { 

            var uri = new URI(spineItem.contentDocumentURI);
            var filename = uri.filename();
            if (contentDocumentHref.trim() === filename.trim()) {
                return true;
            }
        });

        return foundSpineItem.spineIndex;
    },

    getPagesViewInfo : function (spineIndex) {

        var foundPagesViewInfo = _.find(this.get("loadedPagesViews"), function (currPagesViewInfo, index) {

            var foundSpineIndex = _.find(currPagesViewInfo.spineIndexes, function (currSpineIndex) {
                if (currSpineIndex === spineIndex) {
                    return true;
                }
            });

            // Only checking for null and undefined, as "foundSpineIndex" can be 0, which evaluates as falsy
            if (foundSpineIndex !== undefined && foundSpineIndex !== null) {
                return true;
            }
        });

        return foundPagesViewInfo;
    },

    getPagesViewIndex : function (spineIndex) {

        var foundPagesViewIndex;
        _.find(this.get("loadedPagesViews"), function (currPagesViewInfo, index) {

            var foundSpineIndex = _.find(currPagesViewInfo.spineIndexes, function (currSpineIndex) {
                if (currSpineIndex === spineIndex) {
                    return true;
                }
            });

            // Only checking for null and undefined, as "foundSpineIndex" can be 0, which evaluates as falsy
            if (foundSpineIndex !== undefined && foundSpineIndex !== null) {
                foundPagesViewIndex = index;
                return true;
            }
        });

        return foundPagesViewIndex;
    },

    applyPreferences : function (pagesView) {

        var preferences = this.get("viewerSettings");
        pagesView.setSyntheticLayout(preferences.syntheticLayout);
        pagesView.setMargin(preferences.currentMargin);
        pagesView.setTheme(preferences.currentTheme);
        pagesView.setFontSize(preferences.fontSize);
    }
});
    EpubReader.EpubReaderView = Backbone.View.extend({

    initialize : function (options) {

        var that = this;
        this.packageDocumentDOM = options.packageDocumentDOM;
        this.reader = new EpubReader.EpubReader({
            spineInfo : options.spineInfo,
            viewerSettings : options.viewerSettings,
            parentElement : options.readerElement
        });
        // Rationale: Propagate the loaded event after all the content documents are loaded
        this.reader.on("epubLoaded", function () {
            that.trigger("epubLoaded");
            that.$el.css("opacity", "1");
        }, this);

        this.readerBoundElement = options.readerElement;
        this.cfi = new EpubCFIModule();
    },

    render : function () {

        // Set the element that this view will be bound to
        $(this.readerBoundElement).css("opacity", "0");
        this.reader.loadSpineItems();
        this.setElement(this.readerBoundElement);
        return this.el;
    },

    // ------------------------ Public interface ------------------------------------------------------------------------

    // REFACTORING CANDIDATE: This will only work for reflowable page views; there is currently not a mapping between
    //   spine items and the page views in which they are rendered, for FXL epubs. When support for FXL is included, this 
    //   abstraction will include more.
    showSpineItem : function (spineIndex) {

        var pagesViewIndex = this.reader.getPagesViewIndex(spineIndex);
        this.reader.renderPagesView(pagesViewIndex, false, undefined);
        this.reader.getCurrentPagesView().showPageByNumber(1);
    },

    // Rationale: As with the CFI library API, it is up to calling code to ensure that the content document CFI component is
    //   is a reference into the content document pointed to by the supplied spine index. 
    showPageByCFI : function (CFI) {

        // Dereference CFI, get the content document href
        var contentDocHref;
        var spineIndex;
        var pagesView;
        try {
            
            contentDocHref = this.cfi.getContentDocHref(CFI, this.packageDocumentDOM);
            spineIndex = this.reader.findSpineIndex(contentDocHref);
            this.showSpineItem(spineIndex);
            pagesView = this.reader.getCurrentPagesView();
            pagesView.showPageByCFI(CFI);
        }
        catch (error) {
            throw error; 
        }
    },

    showPageByElementId : function (spineIndex, elementId) { 

        // Rationale: Try to locate the element before switching to a new page view try/catch
        this.showSpineItem(spineIndex);
        this.reader.getCurrentPagesView().showPageByHashFragment(elementId);
    },

    nextPage : function () {

        var currentPagesView = this.reader.getCurrentPagesView();
        if (currentPagesView.onLastPage()) {
            this.reader.renderNextPagesView();
        }
        else {
            currentPagesView.nextPage();
        }
    },

    previousPage : function () {

        var currentPagesView = this.reader.getCurrentPagesView();
        if (currentPagesView.onFirstPage()) {
            this.reader.renderPreviousPagesView();
        }
        else {
            currentPagesView.previousPage();
        }
    },

    // REFACTORING CANDIDATE: I don't like that we're maintaining viewer state in the epub object; better that
    //   each time a view was shown, the settings are applied if required

    setFontSize : function (fontSize) {

        var currentView = this.reader.getCurrentPagesView();
        currentView.setFontSize(fontSize);
        this.reader.get("viewerSettings").fontSize = fontSize;
    },

    setMargin : function (margin) {

        var currentView = this.reader.getCurrentPagesView();
        currentView.setMargin(margin);
        this.reader.get("viewerSettings").currentMargin = margin;
    },

    setTheme : function (theme) {

        var currentView = this.reader.getCurrentPagesView();
        currentView.setTheme(theme);
        this.reader.get("viewerSettings").currentTheme = theme;
    },

    setSyntheticLayout : function (isSynthetic) {

        var currentView = this.reader.getCurrentPagesView();
        currentView.setSyntheticLayout(isSynthetic);
        this.reader.get("viewerSettings").syntheticLayout = isSynthetic;
    },

    getNumberOfPages : function () {

        return this.reader.calculatePageNumberInfo().numPages;
    },

    getCurrentPage : function () {

        return this.reader.calculatePageNumberInfo().currentPage;
    },

    addSelectionHighlight : function (id) {

        var contentDocCFIComponent;
        var packageDocCFIComponent;
        var completeCFI;
        var spineIndex;
        var currentViewInfo = this.reader.getCurrentPagesViewInfo();
        spineIndex = currentViewInfo.spineIndexes[0]; // Assumes reflowable
        annotationInfo = currentViewInfo.pagesView.addSelectionHighlight(id);

        // Generate a package document cfi component and construct the whole cfi, append
        contentDocCFIComponent = annotationInfo.CFI;
        packageDocCFIComponent = this.cfi.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, this.packageDocumentDOM);
        completeCFI = this.cfi.generateCompleteCFI(packageDocCFIComponent, contentDocCFIComponent);
        annotationInfo.CFI = completeCFI;

        return annotationInfo;
    },

    addSelectionBookmark : function (id) {

        var contentDocCFIComponent;
        var packageDocCFIComponent;
        var completeCFI;
        var spineIndex;
        var currentViewInfo = this.reader.getCurrentPagesViewInfo();
        spineIndex = currentViewInfo.spineIndexes[0]; // Assumes reflowable
        annotationInfo = currentViewInfo.pagesView.addSelectionBookmark(id);

        // Generate a package document cfi component and construct the whole cfi, append
        contentDocCFIComponent = annotationInfo.CFI;
        packageDocCFIComponent = this.cfi.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, this.packageDocumentDOM);
        completeCFI = this.cfi.generateCompleteCFI(packageDocCFIComponent, contentDocCFIComponent);
        annotationInfo.CFI = completeCFI;

        return annotationInfo;
    },

    addHighlight : function (CFI, id, callback, callbackContext) {

        var annotationInfo;
        var contentDocSpineIndex = this.getSpineIndexFromCFI(CFI);
        this.reader.getRenderedPagesView(contentDocSpineIndex, function (pagesView) {

            try {
                annotationInfo = pagesView.addHighlight(CFI, id);
                callback.call(callbackContext, undefined, contentDocSpineIndex, CFI, annotationInfo);
            }
            catch (error) {
                callback.call(callbackContext, error, undefined, undefined);
            }
        });
    },

    addBookmark : function (CFI, id, callback, callbackContext) {

        var annotationInfo;
        var contentDocSpineIndex = this.getSpineIndexFromCFI(CFI);
        this.reader.getRenderedPagesView(contentDocSpineIndex, function (pagesView) {

            try {
                annotationInfo = pagesView.addBookmark(CFI, id);
                callback.call(callbackContext, undefined, contentDocSpineIndex, CFI, annotationInfo);
            }
            catch (error) {
                callback.call(callbackContext, error, undefined, undefined);
            }
        });
    },

    getViewerSettings : function () {

        return this.reader.get("viewerSettings");
    },

    assignEventHandler : function (eventName, callback, callbackContext) {

        if (eventName === "keydown-left") {
            this.reader.attachEventHandler(eventName, callback, callbackContext);
        }
        else if (eventName === "keydown-right") {
            this.reader.attachEventHandler(eventName, callback, callbackContext);
        } 
        else {
            this.on(eventName, callback, callbackContext);
        }
    },

    removeEventHandler : function (eventName) {

        if (eventName === "keydown-left") {
            this.reader.removeEventHandler(eventName);
        }
        else if (eventName === "keydown-right") {
            this.reader.removeEventHandler(eventName);
        } 
        else {
            this.off(eventName);
        }
    },

    // ----------------------- Private Helpers -----------------------------------------------------------

    getSpineIndexFromCFI : function (CFI) {

        try {
            var contentDocumentHref = this.cfi.getContentDocHref(CFI, this.packageDocumentDOM);
            var spineIndex = this.reader.findSpineIndex(contentDocumentHref);
            return spineIndex;
        }
        catch (error) {
            throw error;
        }
    }
});

    var epubReaderView = new EpubReader.EpubReaderView({
        readerElement : readerBoundElement,
        spineInfo : epubSpineInfo,
        viewerSettings : viewerSettings,
        packageDocumentDOM : packageDocumentDOM
    });

    // Description: The public interface
    return {

        render : function () { return epubReaderView.render.call(epubReaderView); },
        showSpineItem : function (spineIndex) { return epubReaderView.showSpineItem.call(epubReaderView, spineIndex); },
        showPageByCFI : function (CFI) { return epubReaderView.showPageByCFI.call(epubReaderView, CFI); },
        showPageByElementId : function (spineIndex, hashFragmentId) { return epubReaderView.showPageByElementId.call(epubReaderView, spineIndex, hashFragmentId); },
        nextPage : function () { return epubReaderView.nextPage.call(epubReaderView); },
        previousPage : function () { return epubReaderView.previousPage.call(epubReaderView); },
        setFontSize : function (fontSize) { return epubReaderView.setFontSize.call(epubReaderView, fontSize); },
        setMargin : function (margin) { return epubReaderView.setMargin.call(epubReaderView, margin); },
        setTheme : function (theme) { return epubReaderView.setTheme.call(epubReaderView, theme); },
        setSyntheticLayout : function (isSynthetic) { return epubReaderView.setSyntheticLayout.call(epubReaderView, isSynthetic); },
        getNumberOfPages : function () { return epubReaderView.getNumberOfPages.call(epubReaderView); },
        getCurrentPage : function () { return epubReaderView.getCurrentPage.call(epubReaderView); },
        on : function (eventName, callback, callbackContext) { return epubReaderView.assignEventHandler.call(epubReaderView, eventName, callback, callbackContext); },
        off : function (eventName) { return epubReaderView.removeEventHandler.call(epubReaderView, eventName); }, 
        // addSelectionHighlight : function (id) { return epubReaderView.addSelectionHighlight.call(epubReaderView, id); },
        // addSelectionBookmark : function (id) { return epubReaderView.addSelectionBookmark.call(epubReaderView, id); },
        // addHighlight : function (CFI, id, callback, callbackContext) { return epubReaderView.addHighlight.call(epubReaderView, CFI, id, callback, callbackContext); },
        // addBookmark : function (CFI, id, callback, callbackContext) { return epubReaderView.addBookmark.call(epubReaderView, CFI, id, callback, callbackContext); },
        getViewerSettings : function () { return epubReaderView.getViewerSettings.call(epubReaderView); }
    };
};


    // -------------- Initialization of viewer ------------------ //
    var epubParser = new EpubParserModule(packageDocumentURL, packageDocumentXML);
    var packageDocumentDOM = (new window.DOMParser()).parseFromString(packageDocumentXML, "text/xml");
    var epub = new EpubModule(epubParser.parse(), packageDocumentXML);
    var epubViewer = new EpubReaderModule(
        elementToBindReaderTo,
        epub.getSpineInfo(),
        viewerPreferences,
        packageDocumentDOM
    );

    // Description: The public interface
    return {

        // epub module api
        // -- None added so far 

        // epub viewer module api
        render : function () { return epubViewer.render.call(epubViewer); },
        showSpineItem : function (spineIndex) { return epubViewer.showSpineItem.call(epubViewer, spineIndex); },
        showPageByCFI : function (CFI) { return epubViewer.showPageByCFI.call(epubViewer, CFI); },
        showPageByElementId : function (spineIndex, hashFragmentId) { return epubViewer.showPageByElementId.call(epubViewer, spineIndex, hashFragmentId); },
        nextPage : function () { return epubViewer.nextPage.call(epubViewer); },
        previousPage : function () { return epubViewer.previousPage.call(epubViewer); },
        setFontSize : function (fontSize) { return epubViewer.setFontSize.call(epubViewer, fontSize); },
        setMargin : function (margin) { return epubViewer.setMargin.call(epubViewer, margin); },
        setTheme : function (theme) { return epubViewer.setTheme.call(epubViewer, theme); },
        setSyntheticLayout : function (isSynthetic) { return epubViewer.setSyntheticLayout.call(epubViewer, isSynthetic); },
        getNumberOfPages : function () { return epubViewer.getNumberOfPages.call(epubViewer); },
        getCurrentPage : function () { return epubViewer.getCurrentPage.call(epubViewer); },
        on : function (eventName, callback, callbackContext) { return epubViewer.on.call(epubViewer, eventName, callback, callbackContext); },
        off : function (eventName) { return epubViewer.off.call(epubViewer, eventName); }, 
        // addHighlight : function (CFI, id, callback, callbackContext) { return epubViewer.addHighlight.call(epubViewer, CFI, id, callback, callbackContext); },
        // addBookmark : function (CFI, id, callback, callbackContext) { return epubViewer.addBookmark.call(epubViewer, CFI, id, callback, callbackContext); },
        // addSelectionHighlight : function (id) { return epubViewer.addSelectionHighlight.call(epubViewer, id); },
        // addSelectionBookmark : function (id) { return epubViewer.addSelectionBookmark.call(epubViewer, id); },
        getViewerSettings : function () { return epubViewer.getViewerSettings.call(epubViewer); }
    };
};
