{"version":3,"file":"readium-cfi-js.js","sources":["readium_cfi_js/cfi_parser.js","../../readium-js/readium-shared-js/readium-cfi-js/js/cfi_runtime_errors.js","../../readium-js/readium-shared-js/readium-cfi-js/js/cfi_instructions.js","../../readium-js/readium-shared-js/readium-cfi-js/js/cfi_interpreter.js","../../readium-js/readium-shared-js/readium-cfi-js/js/cfi_generator.js","../../readium-js/readium-shared-js/readium-cfi-js/js/cfi_API.js"],"names":["EPUBcfiParser","peg$subclass","child","parent","ctor","this","constructor","prototype","SyntaxError","message","expected","found","offset","line","column","name","parse","input","peg$computePosDetails","pos","advance","details","startPos","endPos","p","ch","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","push","peg$buildException","cleanupExpected","i","sort","a","b","description","length","splice","buildMessage","stringEscape","s","hex","charCodeAt","toString","toUpperCase","replace","expectedDesc","foundDesc","expectedDescs","Array","slice","join","posDetails","peg$parsefragment","s0","s1","s2","s3","substr","peg$c1","peg$FAILED","peg$silentFails","peg$c2","peg$parserange","peg$parsepath","peg$c3","peg$c4","peg$reportedPos","peg$c5","peg$c0","s4","s5","s6","peg$parseindexStep","peg$parselocal_path","peg$c6","peg$c7","peg$c8","peg$c9","peg$parseindirectionStep","peg$parseterminus","peg$c11","peg$c12","peg$c13","peg$c14","peg$parseinteger","peg$c15","peg$c16","peg$parseidAssertion","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$parsetextLocationAssertion","peg$c25","peg$parsevalue","peg$c26","peg$parsecsv","peg$parseparameter","peg$c27","peg$c28","peg$c29","peg$parsevalueNoSpace","peg$c30","peg$c31","peg$c32","peg$c33","peg$parseescapedSpecialChars","peg$parsecharacter","peg$c34","peg$parsespace","peg$parsecircumflex","peg$parsesquareBracket","peg$parseparentheses","peg$parsecomma","peg$parsesemicolon","peg$parseequal","peg$c35","peg$c43","peg$c44","peg$c36","test","peg$c37","peg$c38","peg$c39","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c40","peg$c41","peg$c70","peg$result","options","arguments","peg$startRuleFunctions","fragment","peg$startRuleFunction","type","value","fragmentVal","cfiString","stepVal","localPathVal","rangeLocalPath1Val","rangeLocalPath2Val","path","localPath","range1","range2","localPathStepVal","termStepVal","steps","termStep","stepLengthVal","assertVal","stepLength","idAssertion","undefined","textOffsetValue","textLocAssertVal","offsetValue","textAssertion","idVal","csvVal","paramVal","csv","parameter","paramLHSVal","paramRHSVal","LHSValue","RHSValue","preAssertionVal","postAssertionVal","preAssertion","postAssertion","stringVal","escSpecCharVal","integerVal","concat","bracketVal","paraVal","charVal","startRule","Error","define","global","ret","obj","NodeTypeError","node","OutOfRangeError","targetIndex","maxIndex","TerminusError","terminusType","terminusCondition","CFIAssertionError","expectedAssertion","targetElementAssertion","amd","console","log","EPUBcfi","window","init","$","cfiRuntimeErrors","getNextNode","CFIStepValue","$currNode","classBlacklist","elementBlacklist","idBlacklist","$targetNode","elementNodeStep","inferTargetTextNode","followIndirectionStep","$contentDocument","$blacklistExcluded","$startElement","is","contents","applyBlacklist","children","textTermination","textOffset","elementToInject","$injectedElement","injectCFIMarkerIntoText","targetIdMatchesIdAssertion","$foundNode","attr","numElements","jqueryTargetNodeIndex","indexOutOfRange","retrieveItemRefHref","$itemRefElement","$packageDocument","numChildElements","$textNodeList","nodeNum","nodeOffset","originalText","$injectedNode","$newTextNode","document","ownerDocument","currTextPosition","nodeType","Node","TEXT_NODE","currNodeMaxIndex","nodeValue","insertAfter","eq","createTextNode","COMMENT_NODE","PROCESSING_INSTRUCTION_NODE","target","$elementsWithoutMarkers","currLogicalTextNodeIndex","targetLogicalTextNodeIndex","$targetTextNodeList","prevNodeWasTextNode","parseInt","filter","ELEMENT_NODE","lastChild","$elements","$filteredElements","$currElement","includeInList","each","index","hasClass","CFIInstructions","cfiParser","cfiInstructions","getContentDocHref","CFI","packageDocument","decodedCFI","decodeURI","CFIAST","$packageElement","interpretIndexStepNode","foundHref","searchLocalPathForHref","injectElement","contentDocument","indirectionNode","indirectionStepNum","getFirstIndirectionStepNum","interpretLocalPath","interpretTextTerminusNode","injectRangeElements","rangeCFI","startElementToInject","endElementToInject","$range1TargetElement","$range2TargetElement","startElement","endElement","getTargetElement","getRangeTargetElements","startOffset","endOffset","getTargetElementWithPartialCFI","contentDocumentCFI","getTextTerminusInfoWithPartialCFI","textNode","isRangeCfi","cfi","stepNum","nextStepNode","localPathNode","startStepNum","interpretIndirectionStepNode","indexStepNode","$stepTarget","indirectionStepNode","terminusNode","Interpreter","Parser","generateCharOffsetRangeComponent","rangeStartElement","rangeEndElement","docRange","commonAncestor","$rangeStartParent","$rangeEndParent","range1OffsetStep","range1CFI","range2OffsetStep","range2CFI","commonCFIComponent","validateStartTextNode","createCFITextNodeStep","createCFIElementSteps","substring","createRange","setStart","setEnd","commonAncestorContainer","generateElementRangeComponent","validateStartElement","childNodes","generateRangeComponent","generateCharacterOffsetCFIComponent","startTextNode","characterOffset","textNodeStep","contentDocCFI","generateElementCFIComponent","generatePackageDocumentCFIComponent","contentDocumentName","validateContentDocumentName","validatePackageDocument","$itemRefStartNode","packageDocCFIComponent","generatePackageDocumentCFIComponentWithSpineIndex","spineIndex","generateCompleteCFI","packageDocumentCFIComponent","contentDocumentCFIComponent","$startTextNode","$parentNode","$contentsExcludingMarkers","CFIIndex","indexOfTextNode","indexOfFirstInSequence","textNodeOnlyIndex","characterOffsetSinceUnsplit","finalCharacterOffsetInSequence","data","topLevelElement","currNodePosition","CFIPosition","elementStep","Generator","cfiInterpreter","cfiGenerator","injectElementAtOffset","main"],"mappings":"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","sourcesContent":["EPUBcfiParser = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { fragment: peg$parsefragment },\n        peg$startRuleFunction  = peg$parsefragment,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = \"epubcfi(\",\n        peg$c2 = { type: \"literal\", value: \"epubcfi(\", description: \"\\\"epubcfi(\\\"\" },\n        peg$c3 = \")\",\n        peg$c4 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c5 = function(fragmentVal) { \r\n                \r\n                return { type:\"CFIAST\", cfiString:fragmentVal };\r\n            },\n        peg$c6 = \",\",\n        peg$c7 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c8 = function(stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {\r\n\r\n                return { type:\"range\", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };\r\n          },\n        peg$c9 = function(stepVal, localPathVal) { \r\n\r\n                return { type:\"path\", path:stepVal, localPath:localPathVal }; \r\n            },\n        peg$c10 = [],\n        peg$c11 = null,\n        peg$c12 = function(localPathStepVal, termStepVal) { \r\n\r\n                return { steps:localPathStepVal, termStep:termStepVal?termStepVal:\"\" }; \r\n            },\n        peg$c13 = \"/\",\n        peg$c14 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c15 = \"[\",\n        peg$c16 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c17 = \"]\",\n        peg$c18 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c19 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indexStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c20 = \"!/\",\n        peg$c21 = { type: \"literal\", value: \"!/\", description: \"\\\"!/\\\"\" },\n        peg$c22 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indirectionStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c23 = \":\",\n        peg$c24 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c25 = function(textOffsetValue, textLocAssertVal) { \r\n\r\n                return { type:\"textTerminus\", offsetValue:textOffsetValue, textAssertion: textLocAssertVal?textLocAssertVal[1]:undefined };\r\n            },\n        peg$c26 = function(idVal) { \r\n\r\n                return idVal; \r\n            },\n        peg$c27 = function(csvVal, paramVal) { \r\n\r\n                return { type:\"textLocationAssertion\", csv:csvVal?csvVal:\"\", parameter:paramVal?paramVal:\"\" }; \r\n            },\n        peg$c28 = \";\",\n        peg$c29 = { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n        peg$c30 = \"=\",\n        peg$c31 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c32 = function(paramLHSVal, paramRHSVal) { \r\n\r\n                return { type:\"parameter\", LHSValue:paramLHSVal?paramLHSVal:\"\", RHSValue:paramRHSVal?paramRHSVal:\"\" }; \r\n            },\n        peg$c33 = function(preAssertionVal, postAssertionVal) { \r\n\r\n                return { type:\"csv\", preAssertion:preAssertionVal?preAssertionVal:\"\", postAssertion:postAssertionVal?postAssertionVal:\"\" }; \r\n            },\n        peg$c34 = function(stringVal) { \r\n\r\n                return stringVal.join(''); \r\n            },\n        peg$c35 = function(escSpecCharVal) { \r\n                \r\n                return escSpecCharVal[1]; \r\n            },\n        peg$c36 = /^[1-9]/,\n        peg$c37 = { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n        peg$c38 = /^[0-9]/,\n        peg$c39 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c40 = \".\",\n        peg$c41 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c42 = function(intPartVal, fracPartVal) { \r\n\r\n                return intPartVal.join('') + \".\" + fracPartVal.join(''); \r\n            },\n        peg$c43 = \"0\",\n        peg$c44 = { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n        peg$c45 = function(integerVal) { \r\n\r\n                if (integerVal === \"0\") { \r\n                  return \"0\";\r\n                } \r\n                else { \r\n                  return integerVal[0].concat(integerVal[1].join(''));\r\n                }\r\n            },\n        peg$c46 = \" \",\n        peg$c47 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c48 = function() { return \" \"; },\n        peg$c49 = \"^\",\n        peg$c50 = { type: \"literal\", value: \"^\", description: \"\\\"^\\\"\" },\n        peg$c51 = function() { return \"^\"; },\n        peg$c52 = \"\\\"\",\n        peg$c53 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c54 = function() { return '\"'; },\n        peg$c55 = function(bracketVal) { return bracketVal; },\n        peg$c56 = \"(\",\n        peg$c57 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c58 = function(paraVal) { return paraVal; },\n        peg$c59 = function() { return \",\"; },\n        peg$c60 = function() { return \";\"; },\n        peg$c61 = function() { return \"=\"; },\n        peg$c62 = /^[a-z]/,\n        peg$c63 = { type: \"class\", value: \"[a-z]\", description: \"[a-z]\" },\n        peg$c64 = /^[A-Z]/,\n        peg$c65 = { type: \"class\", value: \"[A-Z]\", description: \"[A-Z]\" },\n        peg$c66 = \"-\",\n        peg$c67 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c68 = \"_\",\n        peg$c69 = { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n        peg$c70 = function(charVal) { return charVal; },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsefragment() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserange();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepath();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c5(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parserange() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselocal_path();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c6;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselocal_path();\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c8(s1, s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c9(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parselocal_path() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseindexStep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseindirectionStep();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseindexStep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseindirectionStep();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseterminus();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c12(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindexStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c19(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindirectionStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s1 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c22(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterminus() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c23;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetextLocationAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c25(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidAssertion() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsetextLocationAssertion() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsecsv();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseparameter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c27(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseparameter() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalueNoSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c30;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c31); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueNoSpace();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c32(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsecsv() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsevalue();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevalueNoSpace() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsevalue() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsespace();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsespace();\n            }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseescapedSpecialChars() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecircumflex();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecircumflex();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsecircumflex();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesquareBracket();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsecircumflex();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseparentheses();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parsecircumflex();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecomma();\n              if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              s2 = peg$parsecircumflex();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsesemicolon();\n                if (s3 !== peg$FAILED) {\n                  s2 = [s2, s3];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsecircumflex();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseequal();\n                  if (s3 !== peg$FAILED) {\n                    s2 = [s2, s3];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c38.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c42(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsespace() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecircumflex() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c49;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsedoubleQuote() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c52;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesquareBracket() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c15;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c16); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c18); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparentheses() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c56;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s1 = peg$c3;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecomma() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesemicolon() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseequal() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecharacter() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s1 === peg$FAILED) {\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s1 === peg$FAILED) {\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s1 = peg$c66;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c67); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 95) {\n                s1 = peg$c68;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s1 = peg$c40;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\ndefine(\"readium_cfi_js/cfi_parser\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.EPUBcfiParser;\n    };\n}(this)));\n\n","//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\n\r\n// Description: This is a set of runtime errors that the CFI interpreter can throw. \r\n// Rationale: These error types extend the basic javascript error object so error things like the stack trace are \r\n//   included with the runtime errors. \r\n\r\n// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, \r\n//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors\r\n//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.\r\n\r\nvar obj = {\r\n\r\nNodeTypeError: function (node, message) {\r\n\r\n    function NodeTypeError () {\r\n\r\n        this.node = node;\r\n    }\r\n\r\n    NodeTypeError.prototype = new Error(message);\r\n    NodeTypeError.constructor = NodeTypeError;\r\n\r\n    return new NodeTypeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.\r\nOutOfRangeError: function (targetIndex, maxIndex, message) {\r\n\r\n    function OutOfRangeError () {\r\n\r\n        this.targetIndex = targetIndex;\r\n        this.maxIndex = maxIndex;\r\n    }\r\n\r\n    OutOfRangeError.prototype = new Error(message);\r\n    OutOfRangeError.constructor = OutOfRangeError()\r\n\r\n    return new OutOfRangeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors\r\n//   that can occur with the various terminus conditions, it'll make more sense to revisit this. \r\nTerminusError: function (terminusType, terminusCondition, message) {\r\n\r\n    function TerminusError () {\r\n\r\n        this.terminusType = terminusType;\r\n        this.terminusCondition = terminusCondition;\r\n    }\r\n\r\n    TerminusError.prototype = new Error(message);\r\n    TerminusError.constructor = TerminusError();\r\n\r\n    return new TerminusError();\r\n},\r\n\r\nCFIAssertionError: function (expectedAssertion, targetElementAssertion, message) {\r\n\r\n    function CFIAssertionError () {\r\n\r\n        this.expectedAssertion = expectedAssertion;\r\n        this.targetElementAssertion = targetElementAssertion;\r\n    }\r\n\r\n    CFIAssertionError.prototype = new Error(message);\r\n    CFIAssertionError.constructor = CFIAssertionError();\r\n\r\n    return new CFIAssertionError();\r\n}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_errors\");\r\n    \r\n    define('readium_cfi_js/cfi_runtime_errors',[],\r\n    function () {\r\n        return obj;\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_errors\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    \r\n    global.EPUBcfi.NodeTypeError = obj.NodeTypeError;\r\n    global.EPUBcfi.OutOfRangeError = obj.OutOfRangeError;\r\n    global.EPUBcfi.TerminusError = obj.TerminusError;\r\n    global.EPUBcfi.CFIAssertionError = obj.CFIAssertionError;\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n","//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiRuntimeErrors) {\r\n    \r\nvar obj = {\r\n\r\n// Description: This model contains the implementation for \"instructions\" included in the EPUB CFI domain specific language (DSL). \r\n//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). \r\n//   This object contains a set of functions that implement each of the executable instructions in the AST. \r\n\r\n\t// ------------------------------------------------------------------------------------ //\r\n\t//  \"PUBLIC\" METHODS (THE API)                                                          //\r\n\t// ------------------------------------------------------------------------------------ //\r\n\r\n\t// Description: Follows a step\r\n\t// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING\r\n\t//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been \r\n\t//   excluded.\r\n\t// REFACTORING CANDIDATE: This should be called \"followIndexStep\"\r\n\tgetNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\t// Find the jquery index for the current node\r\n\t\tvar $targetNode;\r\n\t\tif (CFIStepValue % 2 == 0) {\r\n\r\n\t\t\t$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t}\r\n\r\n\t\treturn $targetNode;\r\n\t},\r\n\r\n\t// Description: This instruction executes an indirection step, where a resource is retrieved using a \r\n\t//   link contained on a attribute of the target element. The attribute that contains the link differs\r\n\t//   depending on the target. \r\n\t// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to \r\n\t//   the cross origin security policy\r\n\tfollowIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\tvar that = this;\r\n\t\tvar $contentDocument; \r\n\t\tvar $blacklistExcluded;\r\n\t\tvar $startElement;\r\n\t\tvar $targetNode;\r\n\r\n\t\t// TODO: This check must be expanded to all the different types of indirection step\r\n\t\t// Only expects iframes, at the moment\r\n\t\tif ($currNode === undefined || !$currNode.is(\"iframe\")) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected an iframe element\");\r\n\t\t}\r\n\r\n\t\t// Check node type; only iframe indirection is handled, at the moment\r\n\t\tif ($currNode.is(\"iframe\")) {\r\n\r\n\t\t\t// Get content\r\n\t\t\t$contentDocument = $currNode.contents();\r\n\r\n\t\t\t// Go to the first XHTML element, which will be the first child of the top-level document object\r\n\t\t\t$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t\t$startElement = $($blacklistExcluded[0]);\r\n\r\n\t\t\t// Follow an index step\r\n\t\t\t$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n\t\t\t// Return that shit!\r\n\t\t\treturn $targetNode; \r\n\t\t}\r\n\r\n\t\t// TODO: Other types of indirection\r\n\t\t// TODO: $targetNode.is(\"embed\")) : src\r\n\t\t// TODO: ($targetNode.is(\"object\")) : data\r\n\t\t// TODO: ($targetNode.is(\"image\") || $targetNode.is(\"xlink:href\")) : xlink:href\r\n\t},\r\n\r\n\t// Description: Injects an element at the specified text node\r\n\t// Arguments: a cfi text termination string, a jquery object to the current node\r\n\t// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus\r\n\ttextTermination : function ($currNode, textOffset, elementToInject) {\r\n\r\n\t\tvar $injectedElement;\r\n\t\t// Get the first node, this should be a text node\r\n\t\tif ($currNode === undefined) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected a terminating node, or node list\");\r\n\t\t} \r\n\t\telse if ($currNode.length === 0) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"no nodes found for termination condition\");\r\n\t\t}\r\n\r\n\t\t$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);\r\n\t\treturn $injectedElement;\r\n\t},\r\n\r\n\t// Description: Checks that the id assertion for the node target matches that on \r\n\t//   the found node. \r\n\ttargetIdMatchesIdAssertion : function ($foundNode, idAssertion) {\r\n\r\n\t\tif ($foundNode.attr(\"id\") === idAssertion) {\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t// ------------------------------------------------------------------------------------ //\r\n\t//  \"PRIVATE\" HELPERS                                                                   //\r\n\t// ------------------------------------------------------------------------------------ //\r\n\r\n\t// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer\r\n\telementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\tvar $targetNode;\r\n\t\tvar $blacklistExcluded;\r\n\t\tvar numElements;\r\n\t\tvar jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;\r\n\r\n\t\t$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n\t\tnumElements = $blacklistExcluded.length;\r\n\r\n\t\tif (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, \"\");\r\n\t\t}\r\n\r\n\t    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);\r\n\t\treturn $targetNode;\r\n\t},\r\n\r\n\tretrieveItemRefHref : function ($itemRefElement, $packageDocument) {\r\n\r\n\t\treturn $(\"#\" + $itemRefElement.attr(\"idref\"), $packageDocument).attr(\"href\");\r\n\t},\r\n\r\n\tindexOutOfRange : function (targetIndex, numChildElements) {\r\n\r\n\t\treturn (targetIndex > numChildElements - 1) ? true : false;\r\n\t},\r\n\r\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \r\n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n    injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {\r\n        var document = $textNodeList[0].ownerDocument;\r\n\r\n        var nodeNum;\r\n        var currNodeLength;\r\n        var currTextPosition = 0;\r\n        var nodeOffset;\r\n        var originalText;\r\n        var $injectedNode;\r\n        var $newTextNode;\r\n        // The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)\r\n        for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {\r\n\r\n            if ($textNodeList[nodeNum].nodeType === Node.TEXT_NODE) {\r\n\r\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length  + currTextPosition;\r\n                nodeOffset = textOffset - currTextPosition;\r\n\r\n                if (currNodeMaxIndex > textOffset) {\r\n\r\n                    // This node is going to be split and the components re-inserted\r\n                    originalText = $textNodeList[nodeNum].nodeValue;\t\r\n\r\n                    // Before part\r\n                    $textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);\r\n\r\n                    // Injected element\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n\r\n                    // After part\r\n                    $newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));\r\n                    $($newTextNode).insertAfter($injectedNode);\r\n\r\n                    return $injectedNode;\r\n                } else if (currNodeMaxIndex == textOffset){\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n                    return $injectedNode;\r\n                }\r\n                else {\r\n                    currTextPosition = currNodeMaxIndex;\r\n                }\r\n            } else if($textNodeList[nodeNum].nodeType === Node.COMMENT_NODE){\r\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + 7 + currTextPosition;\r\n                currTextPosition = currNodeMaxIndex;\r\n            } else if($textNodeList[nodeNum].nodeType === Node.PROCESSING_INSTRUCTION_NODE){\r\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + $textNodeList[nodeNum].target.length + 5\r\n                currTextPosition = currNodeMaxIndex;\r\n            }\r\n        }\r\n\r\n        throw cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"The offset exceeded the length of the text\");\r\n    },\r\n\r\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \r\n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n\r\n\t// Description: This method finds a target text node and then injects an element into the appropriate node\r\n\t// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to \r\n\t//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that\r\n\t//   the set of nodes that compromised the original target text node are inferred and returned.\r\n\t// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, \r\n\t//   element nodes (maybe), or possibly a mix. \r\n\t// REFACTORING CANDIDATE: This method is pretty long (and confusing). Worth investigating to see if it can be refactored into something clearer.\r\n\tinferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\t\t\r\n\t\tvar $elementsWithoutMarkers;\r\n\t\tvar currLogicalTextNodeIndex;\r\n\t\tvar targetLogicalTextNodeIndex;\r\n\t\tvar nodeNum;\r\n\t\tvar $targetTextNodeList;\r\n\t\tvar prevNodeWasTextNode;\r\n\r\n\t\t// Remove any cfi marker elements from the set of elements. \r\n\t\t// Rationale: A filtering function is used, as simply using a class selector with jquery appears to \r\n\t\t//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.\r\n\t\t$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n\t\t// Convert CFIStepValue to logical index; assumes odd integer for the step value\r\n\t\ttargetLogicalTextNodeIndex = ((parseInt(CFIStepValue) + 1) / 2) - 1;\r\n\r\n\t\t// Set text node position counter\r\n\t\tcurrLogicalTextNodeIndex = 0;\r\n\t\tprevNodeWasTextNode = false;\r\n\t\t$targetTextNodeList = $elementsWithoutMarkers.filter(\r\n\t\t\tfunction () {\r\n\r\n\t\t\t\tif (currLogicalTextNodeIndex === targetLogicalTextNodeIndex) {\r\n\r\n\t\t\t\t\t// If it's a text node\r\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Rationale: The logical text node position is only incremented once a group of text nodes (a single logical\r\n\t\t\t\t\t//   text node) has been passed by the loop. \r\n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE)) {\r\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = false;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Don't return any elements\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t}else if (!prevNodeWasTextNode && this.nodeType === Node.ELEMENT_NODE){\r\n                        currLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE) && (this !== $elementsWithoutMarkers.lastChild)) {\r\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// The filtering above should have counted the number of \"logical\" text nodes; this can be used to \r\n\t\t// detect out of range errors\r\n\t\tif ($targetTextNodeList.length === 0) {\r\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(targetLogicalTextNodeIndex, currLogicalTextNodeIndex, \"Index out of range\");\r\n\t\t}\r\n\r\n\t\t// return the text node list\r\n\t\treturn $targetTextNodeList;\r\n\t},\r\n\r\n\tapplyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $filteredElements;\r\n\r\n        $filteredElements = $elements.filter(\r\n            function () {\r\n\r\n                var $currElement = $(this);\r\n                var includeInList = true;\r\n\r\n                if (classBlacklist) {\r\n\r\n                \t// Filter each element with the class type\r\n                \t$.each(classBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.hasClass(value)) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n                \t});\r\n                }\r\n\r\n                if (elementBlacklist) {\r\n                \t\r\n\t                // For each type of element\r\n\t                $.each(elementBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.is(value)) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n\t                });\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (idBlacklist) {\r\n                \t\r\n\t                // For each type of element\r\n\t                $.each(idBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.attr(\"id\") === value) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n\t                });\r\n\t\t\t\t}\r\n\r\n                return includeInList;\r\n            }\r\n        );\r\n\r\n        return $filteredElements;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_instructions\");\r\n    \r\n    define('readium_cfi_js/cfi_instructions',['jquery', './cfi_runtime_errors'],\r\n    function ($, cfiRuntimeErrors) {\r\n        return init($, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_instructions\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.CFIInstructions = \r\n    init($,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n","//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n\r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n\r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n\r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n\r\nvar obj = {\r\n\r\n// Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter\r\n//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will\r\n//   represent the position or area in the EPUB referenced by a CFI.\r\n// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the\r\n//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a\r\n//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps\r\n//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references\r\n//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is\r\n//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to\r\n//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand.\r\n// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free.\r\n//   Might want to make the script die in those instances, once the grammar and interpreter are more stable.\r\n// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated.\r\n//   Whoops. There shouldn't be any interference, however, I think this should be changed.\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    // Description: Find the content document referenced by the spine item. This should be the spine item\r\n    //   referenced by the first indirection step in the CFI.\r\n    // Rationale: This method is a part of the API so that the reading system can \"interact\" the content document\r\n    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with\r\n    //   the reading system, as it stands now.\r\n    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $packageDocument = $(packageDocument);\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n\r\n        if (!CFIAST || CFIAST.type !== \"CFIAST\") {\r\n            throw cfiRuntimeErrors.NodeTypeError(CFIAST, \"expected CFI AST root node\");\r\n        }\r\n\r\n        // Interpet the path node (the package document step)\r\n        var $packageElement = $($(\"package\", $packageDocument)[0]);\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        if (foundHref) {\r\n            return foundHref;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented\r\n        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps in the first local path\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);\r\n\r\n        // Interpret the second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return {\r\n            startElement : $range1TargetElement[0],\r\n            endElement : $range2TargetElement[0]\r\n        };\r\n    },\r\n\r\n    // Description: This method will return the element or node (say, a text node) that is the final target of the\r\n    //   the CFI.\r\n    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: This method will return the start and end elements (along with their char offsets) that are the final targets of the range CFI.\r\n    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Get the start and end character offsets\r\n        var startOffset = parseInt(CFIAST.cfiString.range1.termStep.offsetValue) || undefined;\r\n        var endOffset = parseInt(CFIAST.cfiString.range2.termStep.offsetValue) || undefined;\r\n\r\n        // Return the element (and char offsets) at the end of the CFI\r\n        return {\r\n            startElement: $range1TargetElement[0],\r\n            startOffset: startOffset,\r\n            endElement: $range2TargetElement[0],\r\n            endOffset: endOffset\r\n        };\r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used to reference a target in a content document, without a\r\n    //   package document CFI component.\r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\r\n    // }\r\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\r\n    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n\r\n        // Interpret the path node\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used, with a content document, to return the text node and offset\r\n    //    referenced by the partial CFI.\r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\r\n    // }\r\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\r\n    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var textOffset;\r\n\r\n        // Interpret the path node\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);\r\n        return { textNode : $currElement,\r\n                 textOffset : textOffset\r\n            };\r\n    },\r\n    // Description: This function will determine if the input CFI is expressed as a range\r\n    isRangeCfi: function (cfi) {\r\n        var CFIAST = cfiParser.parse(cfi);\r\n        return CFIAST.cfiString.range1 ? true : false;\r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    getFirstIndirectionStepNum : function (CFIAST) {\r\n\r\n        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it\r\n        //   references is already loaded and has been passed to this method\r\n        var stepNum = 0;\r\n        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];\r\n            if (nextStepNode.type === \"indirectionStep\") {\r\n                return stepNum;\r\n            }\r\n        }\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the\r\n    //   starting step... probably a good idea, this would make the meaning of this method clearer.\r\n    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var stepNum = startStepNum;\r\n        var nextStepNode;\r\n        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n\r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n        }\r\n\r\n        return $currElement;\r\n    },\r\n\r\n    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indexStepNode === undefined || indexStepNode.type !== \"indexStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indexStepNode, \"expected index step node\");\r\n        }\r\n\r\n        // Index step\r\n        var $stepTarget = cfiInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indexStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indirectionStepNode === undefined || indirectionStepNode.type !== \"indirectionStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indirectionStepNode, \"expected indirection step node\");\r\n        }\r\n\r\n        // Indirection step\r\n        var $stepTarget = cfiInstructions.followIndirectionStep(\r\n            indirectionStepNode.stepLength,\r\n            $currElement,\r\n            classBlacklist,\r\n            elementBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indirectionStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus\r\n    //   to inject content into the found node. This will not always be the case, and different types of interpretation\r\n    //   are probably desired.\r\n    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {\r\n\r\n        if (terminusNode === undefined || terminusNode.type !== \"textTerminus\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(terminusNode, \"expected text terminus node\");\r\n        }\r\n\r\n        var $injectedElement = cfiInstructions.textTermination(\r\n            $currElement,\r\n            terminusNode.offsetValue,\r\n            elementToInject\r\n            );\r\n\r\n        return $injectedElement;\r\n    },\r\n\r\n    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Interpret the first local_path node, which is a set of steps and and a terminus condition\r\n        var stepNum = 0;\r\n        var nextStepNode;\r\n        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n\r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n\r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n\r\n            // Found the content document href referenced by the spine item\r\n            if ($currElement.is(\"itemref\")) {\r\n\r\n                return cfiInstructions.retrieveItemRefHref($currElement, $packageDocument);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_interpreter\");\r\n\r\n    define('readium_cfi_js/cfi_interpreter',['jquery', 'readium_cfi_js/cfi_parser', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiParser, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_interpreter\");\r\n\r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Interpreter =\r\n    init($,\r\n        global.EPUBcfi.Parser,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n","//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiInstructions, cfiRuntimeErrors) {\r\n    \r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n    \r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n    \r\nvar obj = {\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var $rangeStartParent;\r\n        var $rangeEndParent;\r\n        var range1OffsetStep;\r\n        var range1CFI;\r\n        var range2OffsetStep;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartTextNode(rangeStartElement);\r\n        this.validateStartTextNode(rangeEndElement);\r\n\r\n        // Parent element is the same\r\n        if ($(rangeStartElement).parent()[0] === $(rangeEndElement).parent()[0]) {\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          \r\n            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1OffsetStep + \",\" + range2OffsetStep;\r\n        }\r\n        else {\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            // Generate terminating offset and range 1\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            $rangeStartParent = $(rangeStartElement).parent();\r\n            if ($rangeStartParent[0] === commonAncestor) {\r\n              // rangeStartElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\r\n              range1CFI = range1OffsetStep;\r\n            } else {\r\n              range1CFI = this.createCFIElementSteps($rangeStartParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;\r\n            }\r\n\r\n            // Generate terminating offset and range 2\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            $rangeEndParent = $(rangeEndElement).parent();\r\n            if ($rangeEndParent[0] === commonAncestor) {\r\n              // rangeEndElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\r\n              range2CFI = range2OffsetStep;\r\n            } else {\r\n              range2CFI = this.createCFIElementSteps($rangeEndParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;\r\n            }\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var range1CFI;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartElement(rangeStartElement);\r\n        this.validateStartElement(rangeEndElement);\r\n\r\n        if (rangeStartElement === rangeEndElement) {\r\n            throw new Error(\"Start and end element cannot be the same for a CFI range\");\r\n        }\r\n\r\n        // Create a document range to find the common ancestor\r\n        docRange = document.createRange();\r\n        docRange.setStart(rangeStartElement, 0);\r\n        docRange.setEnd(rangeEndElement, rangeEndElement.childNodes.length);\r\n        commonAncestor = docRange.commonAncestorContainer;\r\n\r\n        // Generate range 1\r\n        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate range 2\r\n        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate shared component\r\n        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the result\r\n        return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n    },\r\n\r\n    generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        if(rangeStartElement.nodeType === Node.ELEMENT_NODE && rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n            return this.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else if(rangeStartElement.nodeType === Node.TEXT_NODE && rangeEndElement.nodeType === Node.TEXT_NODE){\r\n            return this.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else {\r\n            var docRange;\r\n            var range1CFI;\r\n            var range1OffsetStep;\r\n            var range2CFI;\r\n            var range2OffsetStep;\r\n            var commonAncestor;\r\n            var commonCFIComponent;\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            if(rangeStartElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeStartElement);\r\n                range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeStartElement);\r\n                // Generate terminating offset and range 1\r\n                range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeStartElement).parent().is(commonAncestor)){\r\n                    range1CFI = range1OffsetStep;\r\n                } else {\r\n                    range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;    \r\n                }\r\n            }\r\n\r\n            if(rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeEndElement);\r\n                range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeEndElement);\r\n                // Generate terminating offset and range 2\r\n                range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeEndElement).parent().is(commonAncestor)){\r\n                    range2CFI = range2OffsetStep;\r\n                } else {\r\n                    range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;    \r\n                }                \r\n            }\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    // Description: Generates a character offset CFI \r\n    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the \r\n    //   content document that contains the text node, the package document for this EPUB.\r\n    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var textNodeStep;\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartTextNode(startTextNode, characterOffset);\r\n\r\n        // Create the text node step\r\n        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;\r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartElement(startElement);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startElement), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Remove the ! \r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        this.validateContentDocumentName(contentDocumentName);\r\n        this.validatePackageDocument(packageDocument, contentDocumentName);\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $(\"itemref[idref='\" + contentDocumentName + \"']\", $(packageDocument));\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $($(\"spine\", packageDocument).children()[spineIndex]);\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n\r\n        return \"epubcfi(\" + packageDocumentCFIComponent + contentDocumentCFIComponent + \")\";  \r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    validateStartTextNode : function (startTextNode, characterOffset) {\r\n        \r\n        // Check that the text node to start from IS a text node\r\n        if (!startTextNode) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        } else if (startTextNode.nodeType != 3) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        }\r\n\r\n        // Check that the character offset is within a valid range for the text node supplied\r\n        if (characterOffset < 0) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, 0, \"Character offset cannot be less than 0\");\r\n        }\r\n        else if (characterOffset > startTextNode.nodeValue.length) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, \"character offset cannot be greater than the length of the text node\");\r\n        }\r\n    },\r\n\r\n    validateStartElement : function (startElement) {\r\n\r\n        if (!startElement) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is undefined\");\r\n        }\r\n\r\n        if (!(startElement.nodeType && startElement.nodeType === 1)) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is not an HTML element\");\r\n        }\r\n    },\r\n\r\n    validateContentDocumentName : function (contentDocumentName) {\r\n\r\n        // Check that the idref for the content document has been provided\r\n        if (!contentDocumentName) {\r\n            throw new Error(\"The idref for the content document, as found in the spine, must be supplied\");\r\n        }\r\n    },\r\n\r\n    validatePackageDocument : function (packageDocument, contentDocumentName) {\r\n        \r\n        // Check that the package document is non-empty and contains an itemref element for the supplied idref\r\n        if (!packageDocument) {\r\n            throw new Error(\"A package document must be supplied to generate a CFI\");\r\n        }\r\n        else if ($($(\"itemref[idref='\" + contentDocumentName + \"']\", packageDocument)[0]).length === 0) {\r\n            throw new Error(\"The idref of the content document could not be found in the spine\");\r\n        }\r\n    },\r\n\r\n    // Description: Creates a CFI terminating step to a text node, with a character offset\r\n    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods\r\n    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $parentNode;\r\n        var $contentsExcludingMarkers;\r\n        var CFIIndex;\r\n        var indexOfTextNode;\r\n        var preAssertion;\r\n        var preAssertionStartIndex;\r\n        var textLength;\r\n        var postAssertion;\r\n        var postAssertionEndIndex;\r\n\r\n        // Find text node position in the set of child elements, ignoring any blacklisted elements \r\n        $parentNode = $startTextNode.parent();\r\n        $contentsExcludingMarkers = cfiInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Find the text node index in the parent list, inferring nodes that were originally a single text node\r\n        var prevNodeWasTextNode;\r\n        var indexOfFirstInSequence;\r\n        var textNodeOnlyIndex = 0;\r\n        var characterOffsetSinceUnsplit = 0;\r\n        var finalCharacterOffsetInSequence = 0;\r\n        $.each($contentsExcludingMarkers, \r\n            function (index) {\r\n\r\n            // If this is a text node, check if it matches and return the current index\r\n            if (this.nodeType === Node.TEXT_NODE || !prevNodeWasTextNode) {\r\n\r\n                if (this.nodeType === Node.TEXT_NODE) {\r\n                    if (this === $startTextNode[0]) {\r\n\r\n                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this \r\n                        //   node is a standard one sandwiched between two element nodes. \r\n                        if (prevNodeWasTextNode) {\r\n                            indexOfTextNode = indexOfFirstInSequence;\r\n                            finalCharacterOffsetInSequence = characterOffsetSinceUnsplit;\r\n                        } else {\r\n                            indexOfTextNode = textNodeOnlyIndex;\r\n                        }\r\n                        \r\n                        // Break out of .each loop\r\n                        return false; \r\n                    }\r\n\r\n                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length;\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                        textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                    }\r\n                } else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                    textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // 7 is the size of the html comment tag <!--[comment]-->\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // 5 is the size of the instruction processing tag including the required space between the target and the data <?[target] [data]?>\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                }\r\n            }\r\n            // This node is not a text node\r\n            else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                prevNodeWasTextNode = false;\r\n                indexOfFirstInSequence = undefined;\r\n                characterOffsetSinceUnsplit  = 0;\r\n            } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // <!--[comment]-->\r\n            } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // <?[target] [data]?>\r\n            }\r\n        });\r\n\r\n        // Convert the text node index to a CFI odd-integer representation\r\n        CFIIndex = (indexOfTextNode * 2) + 1;\r\n\r\n        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has\r\n        //   been temporarily removed. \r\n\r\n        // Add pre- and post- text assertions\r\n        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;\r\n        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);\r\n\r\n        // textLength = $startTextNode[0].nodeValue.length;\r\n        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;\r\n        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);\r\n\r\n        // Gotta infer the correct character offset, as well\r\n\r\n        // Return the constructed CFI text node step\r\n        return \"/\" + CFIIndex + \":\" + (finalCharacterOffsetInSequence + characterOffset);\r\n         // + \"[\" + preAssertion + \",\" + postAssertion + \"]\";\r\n    },\r\n\r\n    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $blacklistExcluded;\r\n        var $parentNode;\r\n        var currNodePosition;\r\n        var CFIPosition;\r\n        var idAssertion;\r\n        var elementStep; \r\n\r\n\r\n\r\n        // per https://github.com/readium/readium-cfi-js/issues/28\r\n        // if the currentNode is the same as top level element, we're looking at a text node \r\n        // that's a direct child of \"topLevelElement\" so we don't need to include it in the element step.\r\n        if ($currNode[0] === topLevelElement) {\r\n            return \"\";\r\n        }\r\n\r\n        // Find position of current node in parent list\r\n        $blacklistExcluded = cfiInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);\r\n        $.each($blacklistExcluded, \r\n            function (index, value) {\r\n\r\n                if (this === $currNode[0]) {\r\n\r\n                    currNodePosition = index;\r\n\r\n                    // Break loop\r\n                    return false;\r\n                }\r\n        });\r\n\r\n        // Convert position to the CFI even-integer representation\r\n        CFIPosition = (currNodePosition + 1) * 2;\r\n\r\n        // Create CFI step with id assertion, if the element has an id\r\n        if ($currNode.attr(\"id\")) {\r\n            elementStep = \"/\" + CFIPosition + \"[\" + $currNode.attr(\"id\") + \"]\";\r\n        }\r\n        else {\r\n            elementStep = \"/\" + CFIPosition;\r\n        }\r\n\r\n        // If a parent is an html element return the (last) step for this content document, otherwise, continue.\r\n        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the\r\n        //   top level element.\r\n        $parentNode = $currNode.parent();\r\n        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {\r\n            \r\n            // If the top level node is a type from which an indirection step, add an indirection step character (!)\r\n            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do\r\n            //   not return an indirection character. Every other type of top-level element may require an indirection\r\n            //   step to navigate to, thus requiring that ! is always prepended. \r\n            if (topLevelElement === 'html') {\r\n                return \"!\" + elementStep;\r\n            }\r\n            else {\r\n                return elementStep;\r\n            }\r\n        }\r\n        else {\r\n            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;\r\n        }\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_generator\");\r\n    \r\n    define('readium_cfi_js/cfi_generator',['jquery', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_generator\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Generator = \r\n    init($,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n","//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n\r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n\r\n    if (typeof cfiInterpreter === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInterpreter\");\r\n    }\r\n\r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n\r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n\r\n    if (typeof cfiGenerator === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiGenerator\");\r\n    }\r\n\r\n    var obj = {\r\n\r\n        getContentDocHref : function (CFI, packageDocument) {\r\n            return cfiInterpreter.getContentDocHref(CFI, packageDocument);\r\n        },\r\n        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        isRangeCfi : function (cfi) {\r\n          return cfiInterpreter.isRangeCfi(cfi);\r\n        },\r\n        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n            return cfiGenerator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);\r\n        },\r\n        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {\r\n            return cfiInstructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);\r\n        }\r\n    };\r\n\r\n\r\n    // TODO: remove global (should not be necessary in properly-configured RequireJS build!)\r\n    // ...but we leave it here as a \"legacy\" mechanism to access the CFI lib functionality\r\n    // -----\r\n    obj.CFIInstructions = cfiInstructions;\r\n    obj.Parser = cfiParser;\r\n    obj.Interpreter = cfiInterpreter;\r\n    obj.Generator = cfiGenerator;\r\n\r\n    obj.NodeTypeError= cfiRuntimeErrors.NodeTypeError;\r\n    obj.OutOfRangeError = cfiRuntimeErrors.OutOfRangeError;\r\n    obj.TerminusError = cfiRuntimeErrors.TerminusError;\r\n    obj.CFIAssertionError = cfiRuntimeErrors.CFIAssertionError;\r\n\r\n    global.EPUBcfi = obj;\r\n    // -----\r\n\r\n    console.log(\"#######################################\");\r\n    // console.log(global.EPUBcfi);\r\n    // console.log(\"#######################################\");\r\n\r\n    return obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_API\");\r\n\r\n    define('readium_cfi_js/cfi_API',['readium_cfi_js/cfi_parser', './cfi_interpreter', './cfi_instructions', './cfi_runtime_errors', './cfi_generator'],\r\n    function (cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n\r\n        return init(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_API\");\r\n\r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n\r\n    init(global.EPUBcfi.Parser,\r\n        global.EPUBcfi.Interpreter,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        },\r\n        global.EPUBcfi.Generator);\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\ndefine('readium_cfi_js', ['readium_cfi_js/cfi_API'], function (main) { return main; });\n\n"]}